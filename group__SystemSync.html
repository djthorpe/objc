<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>objc: Synchronization Primitives</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="custom.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea"><h1>objc</h1></div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Synchronization Primitives<div class="ingroups"><a class="el" href="group__System.html">System Runtime</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Implements various synchronization methods for thread-safe operations.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Synchronization Primitives:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__SystemSync.png" border="0" alt="" usemap="#group____SystemSync"/>
<map name="group____SystemSync" id="group____SystemSync">
<area shape="rect" id="node2" href="group__System.html" title="The &quot;system runtime&quot; layer provides low&#45;level functionality specific to the platform. " alt="" coords="5,5,135,32"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsys__mutex__t.html">sys_mutex_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex context structure.  <a href="structsys__mutex__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsys__cond__t.html">sys_cond_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Condition variable context structure.  <a href="structsys__cond__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsys__waitgroup__t.html">sys_waitgroup_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waitgroup context structure.  <a href="structsys__waitgroup__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga6369f074ceab697359030e02dafd6092"><td class="memItemLeft" align="right" valign="top"><a id="ga6369f074ceab697359030e02dafd6092"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SystemSync.html#ga6369f074ceab697359030e02dafd6092">SYS_MUTEX_CTX_SIZE</a>&#160;&#160;&#160;64</td></tr>
<tr class="memdesc:ga6369f074ceab697359030e02dafd6092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer size for platform-specific mutex context dataAdjust based on platform requirements. <br /></td></tr>
<tr class="separator:ga6369f074ceab697359030e02dafd6092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef6857b229197d7e63114185f19d35f8"><td class="memItemLeft" align="right" valign="top"><a id="gaef6857b229197d7e63114185f19d35f8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SystemSync.html#gaef6857b229197d7e63114185f19d35f8">SYS_COND_CTX_SIZE</a>&#160;&#160;&#160;64</td></tr>
<tr class="memdesc:gaef6857b229197d7e63114185f19d35f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer size for platform-specific condition variable context dataAdjust based on platform requirements. <br /></td></tr>
<tr class="separator:gaef6857b229197d7e63114185f19d35f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga673237ae11d9cdc3f4ae46b767de6254"><td class="memItemLeft" align="right" valign="top"><a id="ga673237ae11d9cdc3f4ae46b767de6254"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SystemSync.html#ga673237ae11d9cdc3f4ae46b767de6254">SYS_WAITGROUP_CTX_SIZE</a>&#160;&#160;&#160;128</td></tr>
<tr class="memdesc:ga673237ae11d9cdc3f4ae46b767de6254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer size for platform-specific waitgroup context dataAdjust based on platform requirements. <br /></td></tr>
<tr class="separator:ga673237ae11d9cdc3f4ae46b767de6254"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga57eff626a70b50a6dd10fb2893a1dc2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsys__mutex__t.html">sys_mutex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SystemSync.html#ga57eff626a70b50a6dd10fb2893a1dc2e">sys_mutex_init</a> (void)</td></tr>
<tr class="memdesc:ga57eff626a70b50a6dd10fb2893a1dc2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a new mutex.  <a href="#ga57eff626a70b50a6dd10fb2893a1dc2e">More...</a><br /></td></tr>
<tr class="separator:ga57eff626a70b50a6dd10fb2893a1dc2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga138955bcde069851868561cd20fb876a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SystemSync.html#ga138955bcde069851868561cd20fb876a">sys_mutex_lock</a> (<a class="el" href="structsys__mutex__t.html">sys_mutex_t</a> *mutex)</td></tr>
<tr class="memdesc:ga138955bcde069851868561cd20fb876a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock a mutex, by blocking.  <a href="#ga138955bcde069851868561cd20fb876a">More...</a><br /></td></tr>
<tr class="separator:ga138955bcde069851868561cd20fb876a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec452afb418073c5212e6f9abdcedfe1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SystemSync.html#gaec452afb418073c5212e6f9abdcedfe1">sys_mutex_trylock</a> (<a class="el" href="structsys__mutex__t.html">sys_mutex_t</a> *mutex)</td></tr>
<tr class="memdesc:gaec452afb418073c5212e6f9abdcedfe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to lock a mutex.  <a href="#gaec452afb418073c5212e6f9abdcedfe1">More...</a><br /></td></tr>
<tr class="separator:gaec452afb418073c5212e6f9abdcedfe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c24c3cfd80c2e2b8963aec0b895fe3d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SystemSync.html#ga7c24c3cfd80c2e2b8963aec0b895fe3d">sys_mutex_unlock</a> (<a class="el" href="structsys__mutex__t.html">sys_mutex_t</a> *mutex)</td></tr>
<tr class="memdesc:ga7c24c3cfd80c2e2b8963aec0b895fe3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock a mutex.  <a href="#ga7c24c3cfd80c2e2b8963aec0b895fe3d">More...</a><br /></td></tr>
<tr class="separator:ga7c24c3cfd80c2e2b8963aec0b895fe3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaeb0d92904b70d289a5f4a6a5f93c76a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SystemSync.html#gaaeb0d92904b70d289a5f4a6a5f93c76a">sys_mutex_finalize</a> (<a class="el" href="structsys__mutex__t.html">sys_mutex_t</a> *mutex)</td></tr>
<tr class="memdesc:gaaeb0d92904b70d289a5f4a6a5f93c76a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize and cleanup a mutex.  <a href="#gaaeb0d92904b70d289a5f4a6a5f93c76a">More...</a><br /></td></tr>
<tr class="separator:gaaeb0d92904b70d289a5f4a6a5f93c76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e809159c9598f61c5eb36a6c5e5b040"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsys__cond__t.html">sys_cond_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SystemSync.html#ga3e809159c9598f61c5eb36a6c5e5b040">sys_cond_init</a> (void)</td></tr>
<tr class="memdesc:ga3e809159c9598f61c5eb36a6c5e5b040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a new condition variable.  <a href="#ga3e809159c9598f61c5eb36a6c5e5b040">More...</a><br /></td></tr>
<tr class="separator:ga3e809159c9598f61c5eb36a6c5e5b040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6b426975c75bfd913e4ed517314a036"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SystemSync.html#gad6b426975c75bfd913e4ed517314a036">sys_cond_wait</a> (<a class="el" href="structsys__cond__t.html">sys_cond_t</a> *cond, <a class="el" href="structsys__mutex__t.html">sys_mutex_t</a> *mutex)</td></tr>
<tr class="memdesc:gad6b426975c75bfd913e4ed517314a036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait on a condition variable.  <a href="#gad6b426975c75bfd913e4ed517314a036">More...</a><br /></td></tr>
<tr class="separator:gad6b426975c75bfd913e4ed517314a036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13ddb102887ad005fb1c7406eb6d62df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SystemSync.html#ga13ddb102887ad005fb1c7406eb6d62df">sys_cond_timedwait</a> (<a class="el" href="structsys__cond__t.html">sys_cond_t</a> *cond, <a class="el" href="structsys__mutex__t.html">sys_mutex_t</a> *mutex, uint32_t timeout_ms)</td></tr>
<tr class="memdesc:ga13ddb102887ad005fb1c7406eb6d62df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait on a condition variable with timeout.  <a href="#ga13ddb102887ad005fb1c7406eb6d62df">More...</a><br /></td></tr>
<tr class="separator:ga13ddb102887ad005fb1c7406eb6d62df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf21f413d7edc81444bf3e908cbe4e867"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SystemSync.html#gaf21f413d7edc81444bf3e908cbe4e867">sys_cond_signal</a> (<a class="el" href="structsys__cond__t.html">sys_cond_t</a> *cond)</td></tr>
<tr class="memdesc:gaf21f413d7edc81444bf3e908cbe4e867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal one waiting thread.  <a href="#gaf21f413d7edc81444bf3e908cbe4e867">More...</a><br /></td></tr>
<tr class="separator:gaf21f413d7edc81444bf3e908cbe4e867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2f90e7a405742e4b0b01e9379a5b001"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SystemSync.html#gad2f90e7a405742e4b0b01e9379a5b001">sys_cond_broadcast</a> (<a class="el" href="structsys__cond__t.html">sys_cond_t</a> *cond)</td></tr>
<tr class="memdesc:gad2f90e7a405742e4b0b01e9379a5b001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal all waiting threads.  <a href="#gad2f90e7a405742e4b0b01e9379a5b001">More...</a><br /></td></tr>
<tr class="separator:gad2f90e7a405742e4b0b01e9379a5b001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga024d585a2ba4843ecef30a71a3b56aa7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SystemSync.html#ga024d585a2ba4843ecef30a71a3b56aa7">sys_cond_finalize</a> (<a class="el" href="structsys__cond__t.html">sys_cond_t</a> *cond)</td></tr>
<tr class="memdesc:ga024d585a2ba4843ecef30a71a3b56aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize and cleanup a condition variable.  <a href="#ga024d585a2ba4843ecef30a71a3b56aa7">More...</a><br /></td></tr>
<tr class="separator:ga024d585a2ba4843ecef30a71a3b56aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga054b7429932a28dd301dacca5adb97e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsys__waitgroup__t.html">sys_waitgroup_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SystemSync.html#ga054b7429932a28dd301dacca5adb97e5">sys_waitgroup_init</a> (void)</td></tr>
<tr class="memdesc:ga054b7429932a28dd301dacca5adb97e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a new waitgroup.  <a href="#ga054b7429932a28dd301dacca5adb97e5">More...</a><br /></td></tr>
<tr class="separator:ga054b7429932a28dd301dacca5adb97e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fe6dc303b2686856f6496f8c3589eeb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SystemSync.html#ga6fe6dc303b2686856f6496f8c3589eeb">sys_waitgroup_add</a> (<a class="el" href="structsys__waitgroup__t.html">sys_waitgroup_t</a> *wg, int delta)</td></tr>
<tr class="memdesc:ga6fe6dc303b2686856f6496f8c3589eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to the waitgroup counter.  <a href="#ga6fe6dc303b2686856f6496f8c3589eeb">More...</a><br /></td></tr>
<tr class="separator:ga6fe6dc303b2686856f6496f8c3589eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bc3531da1d947e8b588749cecc2b692"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SystemSync.html#ga6bc3531da1d947e8b588749cecc2b692">sys_waitgroup_done</a> (<a class="el" href="structsys__waitgroup__t.html">sys_waitgroup_t</a> *wg)</td></tr>
<tr class="memdesc:ga6bc3531da1d947e8b588749cecc2b692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement the waitgroup counter.  <a href="#ga6bc3531da1d947e8b588749cecc2b692">More...</a><br /></td></tr>
<tr class="separator:ga6bc3531da1d947e8b588749cecc2b692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabca9a01a0834ad14251f39c45a1120d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SystemSync.html#gabca9a01a0834ad14251f39c45a1120d6">sys_waitgroup_finalize</a> (<a class="el" href="structsys__waitgroup__t.html">sys_waitgroup_t</a> *wg)</td></tr>
<tr class="memdesc:gabca9a01a0834ad14251f39c45a1120d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize and cleanup a waitgroup - wait for completion then cleanup.  <a href="#gabca9a01a0834ad14251f39c45a1120d6">More...</a><br /></td></tr>
<tr class="separator:gabca9a01a0834ad14251f39c45a1120d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Implements various synchronization methods for thread-safe operations. </p>
<p>Three main synchronization primitives are provided. A mutual exclusion type (or "mutex") is used to protect shared resources from concurrent access. You will need one mutex for each shared resource that requires protection against concurrent access. You should always lock the mutex before accessing the shared resource, and unlock it after you are done.</p>
<p>Condition variables allow threads to wait for certain conditions to be met before proceeding. One thread can signal a condition variable, and other threads can wait on it. This is useful for implementing producer/consumer patterns, where one thread produces data and another thread consumes it.</p>
<p>Waitgroups allow one thread to wait for a collection of threads to finish executing. This is useful for synchronizing the completion of multiple threads before proceeding. You can add threads to a waitgroup, and then wait for all of them to complete. This is useful for ensuring that all threads have finished their work before proceeding. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad2f90e7a405742e4b0b01e9379a5b001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2f90e7a405742e4b0b01e9379a5b001">&#9670;&nbsp;</a></span>sys_cond_broadcast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sys_cond_broadcast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__cond__t.html">sys_cond_t</a> *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal all waiting threads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>Pointer to the condition variable to broadcast </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false on error</dd></dl>
<p>Wakes up all threads waiting on the condition variable. If no threads are waiting, this function has no effect. The associated mutex should be locked when calling this function for predictable behavior. </p>

</div>
</div>
<a id="ga024d585a2ba4843ecef30a71a3b56aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga024d585a2ba4843ecef30a71a3b56aa7">&#9670;&nbsp;</a></span>sys_cond_finalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_cond_finalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__cond__t.html">sys_cond_t</a> *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize and cleanup a condition variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>Pointer to the condition variable to finalize</td></tr>
  </table>
  </dd>
</dl>
<p>Releases all resources associated with the condition variable and renders it unusable. No threads should be waiting on the condition variable when this function is called. </p>

</div>
</div>
<a id="ga3e809159c9598f61c5eb36a6c5e5b040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e809159c9598f61c5eb36a6c5e5b040">&#9670;&nbsp;</a></span>sys_cond_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsys__cond__t.html">sys_cond_t</a> sys_cond_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a new condition variable. </p>
<dl class="section return"><dt>Returns</dt><dd>Initialized condition variable structure</dd></dl>
<p>Creates and initializes a new condition variable for thread synchronization. The condition variable is ready for use with wait/signal operations. The returned condition variable must be finalized with <a class="el" href="group__SystemSync.html#ga024d585a2ba4843ecef30a71a3b56aa7" title="Finalize and cleanup a condition variable. ">sys_cond_finalize()</a> </p>

</div>
</div>
<a id="gaf21f413d7edc81444bf3e908cbe4e867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf21f413d7edc81444bf3e908cbe4e867">&#9670;&nbsp;</a></span>sys_cond_signal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sys_cond_signal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__cond__t.html">sys_cond_t</a> *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal one waiting thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>Pointer to the condition variable to signal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false on error</dd></dl>
<p>Wakes up one thread waiting on the condition variable. If no threads are waiting, this function has no effect. The associated mutex should be locked when calling this function for predictable behavior. </p>

</div>
</div>
<a id="ga13ddb102887ad005fb1c7406eb6d62df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13ddb102887ad005fb1c7406eb6d62df">&#9670;&nbsp;</a></span>sys_cond_timedwait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sys_cond_timedwait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__cond__t.html">sys_cond_t</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsys__mutex__t.html">sys_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait on a condition variable with timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>Pointer to the condition variable to wait on </td></tr>
    <tr><td class="paramname">mutex</td><td>Pointer to the mutex that must be locked by the calling thread </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>Timeout in milliseconds (0 = no timeout) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if signaled, false if timeout or error</dd></dl>
<p>Like <a class="el" href="group__SystemSync.html#gad6b426975c75bfd913e4ed517314a036" title="Wait on a condition variable. ">sys_cond_wait()</a> but returns after timeout_ms milliseconds if not signaled. Returns true if signaled, false if timeout or error occurred. </p>

</div>
</div>
<a id="gad6b426975c75bfd913e4ed517314a036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6b426975c75bfd913e4ed517314a036">&#9670;&nbsp;</a></span>sys_cond_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sys_cond_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__cond__t.html">sys_cond_t</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsys__mutex__t.html">sys_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mutex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait on a condition variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>Pointer to the condition variable to wait on </td></tr>
    <tr><td class="paramname">mutex</td><td>Pointer to the mutex that must be locked by the calling thread </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the wait completed successfully, false on error</dd></dl>
<p>Atomically releases the mutex and waits for the condition variable to be signaled. Upon return, the mutex is reacquired. The mutex must be locked by the calling thread before calling this function. </p>

</div>
</div>
<a id="gaaeb0d92904b70d289a5f4a6a5f93c76a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaeb0d92904b70d289a5f4a6a5f93c76a">&#9670;&nbsp;</a></span>sys_mutex_finalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_mutex_finalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__mutex__t.html">sys_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize and cleanup a mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>Pointer to the mutex to finalize</td></tr>
  </table>
  </dd>
</dl>
<p>Releases all resources associated with the mutex and renders it unusable. The mutex should not be locked when this function is called. </p>

</div>
</div>
<a id="ga57eff626a70b50a6dd10fb2893a1dc2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57eff626a70b50a6dd10fb2893a1dc2e">&#9670;&nbsp;</a></span>sys_mutex_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsys__mutex__t.html">sys_mutex_t</a> sys_mutex_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a new mutex. </p>
<dl class="section return"><dt>Returns</dt><dd>Initialized mutex structure</dd></dl>
<p>Creates and initializes a new mutex for thread synchronization. The mutex is initially unlocked and ready for use. The returned mutex must be finalized with <a class="el" href="group__SystemSync.html#gaaeb0d92904b70d289a5f4a6a5f93c76a" title="Finalize and cleanup a mutex. ">sys_mutex_finalize()</a> </p>

</div>
</div>
<a id="ga138955bcde069851868561cd20fb876a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga138955bcde069851868561cd20fb876a">&#9670;&nbsp;</a></span>sys_mutex_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sys_mutex_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__mutex__t.html">sys_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock a mutex, by blocking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>Pointer to the mutex to lock </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the mutex was successfully locked, false on error</dd></dl>
<p>Attempts to lock the specified mutex. If the mutex is already locked by another thread, this function will block until the mutex becomes available. Every successful lock must be paired with <a class="el" href="group__SystemSync.html#ga7c24c3cfd80c2e2b8963aec0b895fe3d" title="Unlock a mutex. ">sys_mutex_unlock()</a> Attempting to lock an already owned mutex may result in deadlock </p>

</div>
</div>
<a id="gaec452afb418073c5212e6f9abdcedfe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec452afb418073c5212e6f9abdcedfe1">&#9670;&nbsp;</a></span>sys_mutex_trylock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sys_mutex_trylock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__mutex__t.html">sys_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to lock a mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>Pointer to the mutex to try locking </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the mutex was successfully locked, false if already locked or on error</dd></dl>
<p>Attempts to lock the specified mutex without blocking. If the mutex is already locked, this function returns immediately with false. Every successful trylock must be paired with <a class="el" href="group__SystemSync.html#ga7c24c3cfd80c2e2b8963aec0b895fe3d" title="Unlock a mutex. ">sys_mutex_unlock()</a> </p>

</div>
</div>
<a id="ga7c24c3cfd80c2e2b8963aec0b895fe3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c24c3cfd80c2e2b8963aec0b895fe3d">&#9670;&nbsp;</a></span>sys_mutex_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sys_mutex_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__mutex__t.html">sys_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock a mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>Pointer to the mutex to unlock </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the mutex was successfully unlocked, false on error</dd></dl>
<p>Releases a previously acquired mutex lock, allowing other threads to acquire the mutex. Only the thread that locked the mutex should unlock it. </p>

</div>
</div>
<a id="ga6fe6dc303b2686856f6496f8c3589eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fe6dc303b2686856f6496f8c3589eeb">&#9670;&nbsp;</a></span>sys_waitgroup_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sys_waitgroup_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__waitgroup__t.html">sys_waitgroup_t</a> *&#160;</td>
          <td class="paramname"><em>wg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to the waitgroup counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wg</td><td>Pointer to the waitgroup </td></tr>
    <tr><td class="paramname">delta</td><td>Number to add to the counter (must be positive) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false on error</dd></dl>
<p>Increments the waitgroup counter by delta. This should be called before starting goroutines that the waitgroup should wait for. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="clock_2main_8c-example.html#a15">clock/main.c</a>, and <a class="el" href="pico_2multicore_2main_8c-example.html#a7">pico/multicore/main.c</a>.</dd>
</dl>
</div>
</div>
<a id="ga6bc3531da1d947e8b588749cecc2b692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bc3531da1d947e8b588749cecc2b692">&#9670;&nbsp;</a></span>sys_waitgroup_done()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sys_waitgroup_done </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__waitgroup__t.html">sys_waitgroup_t</a> *&#160;</td>
          <td class="paramname"><em>wg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrement the waitgroup counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wg</td><td>Pointer to the waitgroup </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false on error</dd></dl>
<p>Decrements the waitgroup counter by 1. This should be called when a goroutine finishes its work. If the counter reaches 0, all threads waiting on sys_waitgroup_wait() will be woken up. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="clock_2main_8c-example.html#a9">clock/main.c</a>, and <a class="el" href="pico_2multicore_2main_8c-example.html#a5">pico/multicore/main.c</a>.</dd>
</dl>
</div>
</div>
<a id="gabca9a01a0834ad14251f39c45a1120d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabca9a01a0834ad14251f39c45a1120d6">&#9670;&nbsp;</a></span>sys_waitgroup_finalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_waitgroup_finalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__waitgroup__t.html">sys_waitgroup_t</a> *&#160;</td>
          <td class="paramname"><em>wg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize and cleanup a waitgroup - wait for completion then cleanup. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wg</td><td>Pointer to the waitgroup to finalize</td></tr>
  </table>
  </dd>
</dl>
<p>Blocks until the waitgroup counter reaches 0, then releases all resources associated with the waitgroup and renders it unusable. The waitgroup counter should reach 0 through done() calls from worker threads. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="clock_2main_8c-example.html#a17">clock/main.c</a>, and <a class="el" href="pico_2multicore_2main_8c-example.html#a9">pico/multicore/main.c</a>.</dd>
</dl>
</div>
</div>
<a id="ga054b7429932a28dd301dacca5adb97e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga054b7429932a28dd301dacca5adb97e5">&#9670;&nbsp;</a></span>sys_waitgroup_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsys__waitgroup__t.html">sys_waitgroup_t</a> sys_waitgroup_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a new waitgroup. </p>
<dl class="section return"><dt>Returns</dt><dd>Initialized waitgroup structure</dd></dl>
<p>Creates and initializes a new waitgroup for thread synchronization. The waitgroup counter starts at 0. The returned waitgroup must be finalized with <a class="el" href="group__SystemSync.html#gabca9a01a0834ad14251f39c45a1120d6" title="Finalize and cleanup a waitgroup - wait for completion then cleanup. ">sys_waitgroup_finalize()</a> </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="clock_2main_8c-example.html#a13">clock/main.c</a>, and <a class="el" href="pico_2multicore_2main_8c-example.html#a6">pico/multicore/main.c</a>.</dd>
</dl>
</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
  </ul>
</div>
</body>
</html>
