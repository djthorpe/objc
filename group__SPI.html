<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>objc: SPI</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="custom.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea"><h1>objc</h1></div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SPI<div class="ingroups"><a class="el" href="group__System.html">System Runtime</a> &raquo; <a class="el" href="group__Hardware.html">Hardware Interfaces</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Serial Peripheral Interface (SPI) interface.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for SPI:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__SPI.png" border="0" alt="" usemap="#group____SPI"/>
<map name="group____SPI" id="group____SPI">
<area shape="rect" id="node2" href="group__Hardware.html" title="Managing hardware resources, peripherals, and low&#45;level operations. " alt="" coords="5,5,160,32"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhw__spi__t.html">hw_spi_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI adapter.  <a href="structhw__spi__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga73bb1ed8fc8d79e3d54eb0551037f318"><td class="memItemLeft" align="right" valign="top"><a id="ga73bb1ed8fc8d79e3d54eb0551037f318"></a>
typedef struct <a class="el" href="structhw__spi__t.html">hw_spi_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#ga73bb1ed8fc8d79e3d54eb0551037f318">hw_spi_t</a></td></tr>
<tr class="memdesc:ga73bb1ed8fc8d79e3d54eb0551037f318"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI adapter. <br /></td></tr>
<tr class="separator:ga73bb1ed8fc8d79e3d54eb0551037f318"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga495ccd8d68452751202096ca29c298c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhw__spi__t.html">hw_spi_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#ga495ccd8d68452751202096ca29c298c8">hw_spi_init_default</a> (bool cs_active_low, uint32_t baudrate)</td></tr>
<tr class="memdesc:ga495ccd8d68452751202096ca29c298c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a SPI interface using default pins and adapter.  <a href="#ga495ccd8d68452751202096ca29c298c8">More...</a><br /></td></tr>
<tr class="separator:ga495ccd8d68452751202096ca29c298c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b191073e6e0f6e8c4c5d0a0a3e6778f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhw__spi__t.html">hw_spi_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#ga7b191073e6e0f6e8c4c5d0a0a3e6778f">hw_spi_init</a> (uint8_t adapter, uint8_t sck, uint8_t tx, uint8_t rx, uint8_t cs, bool cs_active_low, uint32_t baudrate)</td></tr>
<tr class="memdesc:ga7b191073e6e0f6e8c4c5d0a0a3e6778f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a SPI interface with specific adapter and pins.  <a href="#ga7b191073e6e0f6e8c4c5d0a0a3e6778f">More...</a><br /></td></tr>
<tr class="separator:ga7b191073e6e0f6e8c4c5d0a0a3e6778f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f450234054a0123f578c61dd935642c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#ga9f450234054a0123f578c61dd935642c">hw_spi_finalize</a> (<a class="el" href="structhw__spi__t.html">hw_spi_t</a> *spi)</td></tr>
<tr class="memdesc:ga9f450234054a0123f578c61dd935642c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize and release a SPI interface.  <a href="#ga9f450234054a0123f578c61dd935642c">More...</a><br /></td></tr>
<tr class="separator:ga9f450234054a0123f578c61dd935642c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad66e843c835a0a8163d713651c5526a9"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#gad66e843c835a0a8163d713651c5526a9">hw_spi_count</a> (void)</td></tr>
<tr class="memdesc:gad66e843c835a0a8163d713651c5526a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of available SPI adapters.  <a href="#gad66e843c835a0a8163d713651c5526a9">More...</a><br /></td></tr>
<tr class="separator:gad66e843c835a0a8163d713651c5526a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga619385b5cb3450dbe77417ab9ffd5195"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#ga619385b5cb3450dbe77417ab9ffd5195">hw_spi_valid</a> (<a class="el" href="structhw__spi__t.html">hw_spi_t</a> *spi)</td></tr>
<tr class="memdesc:ga619385b5cb3450dbe77417ab9ffd5195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get true if the SPI interface is valid.  <a href="#ga619385b5cb3450dbe77417ab9ffd5195">More...</a><br /></td></tr>
<tr class="separator:ga619385b5cb3450dbe77417ab9ffd5195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b81730fe863e422ad062979fb981a63"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#ga4b81730fe863e422ad062979fb981a63">hw_spi_xfr</a> (<a class="el" href="structhw__spi__t.html">hw_spi_t</a> *spi, void *data, size_t tx, size_t rx)</td></tr>
<tr class="memdesc:ga4b81730fe863e422ad062979fb981a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a SPI transfer operation (read, write, or combined).  <a href="#ga4b81730fe863e422ad062979fb981a63">More...</a><br /></td></tr>
<tr class="separator:ga4b81730fe863e422ad062979fb981a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aed37219ae9b895fff3882d4f86c97c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#ga1aed37219ae9b895fff3882d4f86c97c">hw_spi_read</a> (<a class="el" href="structhw__spi__t.html">hw_spi_t</a> *spi, uint8_t reg, void *data, size_t len)</td></tr>
<tr class="memdesc:ga1aed37219ae9b895fff3882d4f86c97c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from a specific register of a SPI device.  <a href="#ga1aed37219ae9b895fff3882d4f86c97c">More...</a><br /></td></tr>
<tr class="separator:ga1aed37219ae9b895fff3882d4f86c97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac27e41e21c7edca256ce1f32b0f5efc0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#gac27e41e21c7edca256ce1f32b0f5efc0">hw_spi_write</a> (<a class="el" href="structhw__spi__t.html">hw_spi_t</a> *spi, uint8_t reg, const void *data, size_t len)</td></tr>
<tr class="memdesc:gac27e41e21c7edca256ce1f32b0f5efc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to a specific register of a SPI device.  <a href="#gac27e41e21c7edca256ce1f32b0f5efc0">More...</a><br /></td></tr>
<tr class="separator:gac27e41e21c7edca256ce1f32b0f5efc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Serial Peripheral Interface (SPI) interface. </p>
<p>This module provides functions to initialize SPI peripherals, and bi-directional data transfer with SPI devices in master mode. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad66e843c835a0a8163d713651c5526a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad66e843c835a0a8163d713651c5526a9">&#9670;&nbsp;</a></span>hw_spi_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t hw_spi_count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the total number of available SPI adapters. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of SPI adapters available on the hardware platform.</dd></dl>
<p>Returns the number of logical SPI adapters that can be used in the system. These are usually numbered from 0 to <a class="el" href="group__SPI.html#gad66e843c835a0a8163d713651c5526a9" title="Get the total number of available SPI adapters. ">hw_spi_count()</a> - 1. If zero is returned, it indicates that SPI functionality is not available. </p>

</div>
</div>
<a id="ga9f450234054a0123f578c61dd935642c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f450234054a0123f578c61dd935642c">&#9670;&nbsp;</a></span>hw_spi_finalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_spi_finalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhw__spi__t.html">hw_spi_t</a> *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize and release a SPI interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spi</td><td>Pointer to the SPI structure to finalize.</td></tr>
  </table>
  </dd>
</dl>
<p>This function releases the SPI interface and frees any associated resources. After calling this function, the SPI interface should not be used for further operations. </p>

</div>
</div>
<a id="ga7b191073e6e0f6e8c4c5d0a0a3e6778f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b191073e6e0f6e8c4c5d0a0a3e6778f">&#9670;&nbsp;</a></span>hw_spi_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhw__spi__t.html">hw_spi_t</a> hw_spi_init </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>adapter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cs_active_low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baudrate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a SPI interface with specific adapter and pins. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adapter</td><td>The SPI adapter number to use (0 to <a class="el" href="group__SPI.html#gad66e843c835a0a8163d713651c5526a9" title="Get the total number of available SPI adapters. ">hw_spi_count()</a>-1). </td></tr>
    <tr><td class="paramname">sck</td><td>The GPIO pin number to use for SPI Clock (SCK). </td></tr>
    <tr><td class="paramname">tx</td><td>The GPIO pin number to use for SPI Master Out Slave In (MOSI). </td></tr>
    <tr><td class="paramname">rx</td><td>The GPIO pin number to use for SPI Master In Slave Out (MISO). </td></tr>
    <tr><td class="paramname">cs</td><td>The GPIO pin number to use for SPI Chip Select (CS). </td></tr>
    <tr><td class="paramname">cs_active_low</td><td>True if the Chip Select (CS) pin is active low, false otherwise. </td></tr>
    <tr><td class="paramname">baudrate</td><td>The desired SPI baud rate (e.g., 100000 for 100kHz). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A SPI structure representing the initialized interface.</dd></dl>
<p>This function initializes a SPI interface using the specified adapter and GPIO pins for MOSI, MISO, and SCK lines. The adapter number should be valid and the specified pins should be capable of SPI functionality.</p>
<p>If the CS value is set to 0, it will not be used for reading or writing.</p>
<dl class="section note"><dt>Note</dt><dd>The specified pins must support SPI functionality. </dd>
<dd>
Pin assignments are platform-dependent. </dd></dl>

</div>
</div>
<a id="ga495ccd8d68452751202096ca29c298c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga495ccd8d68452751202096ca29c298c8">&#9670;&nbsp;</a></span>hw_spi_init_default()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhw__spi__t.html">hw_spi_t</a> hw_spi_init_default </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cs_active_low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baudrate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a SPI interface using default pins and adapter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cs_active_low</td><td>True if the Chip Select (CS) pin is active low, false otherwise. </td></tr>
    <tr><td class="paramname">baudrate</td><td>The desired SPI baud rate (e.g., 100000 for 100kHz). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A SPI structure representing the initialized interface.</dd></dl>
<p>This function initializes the default SPI interface using platform-specific default pins and adapter settings. This is the simplest way to get SPI functionality without needing to specify pin assignments. </p>

</div>
</div>
<a id="ga1aed37219ae9b895fff3882d4f86c97c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1aed37219ae9b895fff3882d4f86c97c">&#9670;&nbsp;</a></span>hw_spi_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t hw_spi_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhw__spi__t.html">hw_spi_t</a> *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from a specific register of a SPI device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spi</td><td>Pointer to the SPI structure. </td></tr>
    <tr><td class="paramname">reg</td><td>Register address to read from. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the buffer where read data will be stored. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes successfully read, or 0 on failure.</dd></dl>
<p>This function writes the register address and then reads the specified number of bytes with automatic CS control. </p>

</div>
</div>
<a id="ga619385b5cb3450dbe77417ab9ffd5195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga619385b5cb3450dbe77417ab9ffd5195">&#9670;&nbsp;</a></span>hw_spi_valid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool hw_spi_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhw__spi__t.html">hw_spi_t</a> *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get true if the SPI interface is valid. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the SPI interface is valid, false otherwise.</dd></dl>
<p>The result of hw_spi_init can return an empty SPI structure if the initialization fails. This function checks if the SPI interface is valid. </p>

<p class="definition">Definition at line <a class="el" href="spi_8h_source.html#l00111">111</a> of file <a class="el" href="spi_8h_source.html">spi.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;                                               {</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;  <span class="keywordflow">return</span> spi &amp;&amp; spi-&gt;<a class="code" href="structhw__spi__t.html#aa89c8b0a8741f90f4d17be4007a6aefa">baudrate</a> &gt; 0;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;}</div><div class="ttc" id="structhw__spi__t_html_aa89c8b0a8741f90f4d17be4007a6aefa"><div class="ttname"><a href="structhw__spi__t.html#aa89c8b0a8741f90f4d17be4007a6aefa">hw_spi_t::baudrate</a></div><div class="ttdeci">uint32_t baudrate</div><div class="ttdoc">SPI baud rate in Hz. </div><div class="ttdef"><b>Definition:</b> <a href="spi_8h_source.html#l00032">spi.h:32</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gac27e41e21c7edca256ce1f32b0f5efc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac27e41e21c7edca256ce1f32b0f5efc0">&#9670;&nbsp;</a></span>hw_spi_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t hw_spi_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhw__spi__t.html">hw_spi_t</a> *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to a specific register of a SPI device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spi</td><td>Pointer to the SPI structure. </td></tr>
    <tr><td class="paramname">reg</td><td>Register address to write to. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the data to write (can be NULL if len is 0). </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes successfully written, or 0 on failure.</dd></dl>
<p>This function writes the register address followed by the data with automatic CS control. </p>

</div>
</div>
<a id="ga4b81730fe863e422ad062979fb981a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b81730fe863e422ad062979fb981a63">&#9670;&nbsp;</a></span>hw_spi_xfr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t hw_spi_xfr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhw__spi__t.html">hw_spi_t</a> *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a SPI transfer operation (read, write, or combined). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spi</td><td>Pointer to the SPI structure. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the data buffer for read/write operations. </td></tr>
    <tr><td class="paramname">tx</td><td>Number of bytes to transmit from the data buffer. </td></tr>
    <tr><td class="paramname">rx</td><td>Number of bytes to receive into the data buffer (after tx bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes successfully transferred, or 0 on failure.</dd></dl>
<p>This function performs a generic SPI transfer with automatic CS control. For combined operations, transmit data is sent first, then receive data is read into the buffer starting at offset tx.</p>
<dl class="section note"><dt>Note</dt><dd>The CS pin is automatically asserted before and deasserted after the transfer. </dd>
<dd>
For combined transfers, ensure the data buffer is large enough for tx + rx bytes. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
  </ul>
</div>
</body>
</html>
