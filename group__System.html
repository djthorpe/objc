<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>objc: System Management</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="custom.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea"><h1>objc</h1></div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">System Management</div>  </div>
</div><!--header-->
<div class="contents">

<p>System methods for managing memory, threads and resources.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsys__event__queue__t.html">sys_event_queue_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event queue structure for producer/consumer patterns.  <a href="structsys__event__queue__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsys__hash__t.html">sys_hash_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash context structure.  <a href="structsys__hash__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsys__mutex__t.html">sys_mutex_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex context structure.  <a href="structsys__mutex__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsys__cond__t.html">sys_cond_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Condition variable context structure.  <a href="structsys__cond__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsys__waitgroup__t.html">sys_waitgroup_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waitgroup context structure.  <a href="structsys__waitgroup__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsys__time.html">sys_time</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a system time structure.  <a href="structsys__time.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsys__timer__t.html">sys_timer_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer context structure.  <a href="structsys__timer__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga3700f36a38e34fc20ed338df76692bab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga3700f36a38e34fc20ed338df76692bab">SYS_HASH_SIZE</a>&#160;&#160;&#160;32</td></tr>
<tr class="memdesc:ga3700f36a38e34fc20ed338df76692bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the hash.  <a href="#ga3700f36a38e34fc20ed338df76692bab">More...</a><br /></td></tr>
<tr class="separator:ga3700f36a38e34fc20ed338df76692bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17b5573319cb8e7d1a7afdeae1a657a9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga17b5573319cb8e7d1a7afdeae1a657a9">SYS_HASH_CTX_SIZE</a>&#160;&#160;&#160;128</td></tr>
<tr class="memdesc:ga17b5573319cb8e7d1a7afdeae1a657a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the hash context buffer.  <a href="#ga17b5573319cb8e7d1a7afdeae1a657a9">More...</a><br /></td></tr>
<tr class="separator:ga17b5573319cb8e7d1a7afdeae1a657a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga208fc3368b9e3ed3d9d22e9be875731e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga208fc3368b9e3ed3d9d22e9be875731e">SYS_TIMER_CTX_SIZE</a>&#160;&#160;&#160;32</td></tr>
<tr class="memdesc:ga208fc3368b9e3ed3d9d22e9be875731e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the timer context buffer.  <a href="#ga208fc3368b9e3ed3d9d22e9be875731e">More...</a><br /></td></tr>
<tr class="separator:ga208fc3368b9e3ed3d9d22e9be875731e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga2bdd4be7e6e04b4ee95e0459ff001702"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga2bdd4be7e6e04b4ee95e0459ff001702">sys_event_t</a></td></tr>
<tr class="memdesc:ga2bdd4be7e6e04b4ee95e0459ff001702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event type for queue items.  <a href="#ga2bdd4be7e6e04b4ee95e0459ff001702">More...</a><br /></td></tr>
<tr class="separator:ga2bdd4be7e6e04b4ee95e0459ff001702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44d92420e9c1148c746ce7e89a81075d"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga44d92420e9c1148c746ce7e89a81075d">sys_thread_func_t</a>) (void *arg)</td></tr>
<tr class="memdesc:ga44d92420e9c1148c746ce7e89a81075d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread function signatureFunction signature for thread entry points.  <a href="#ga44d92420e9c1148c746ce7e89a81075d">More...</a><br /></td></tr>
<tr class="separator:ga44d92420e9c1148c746ce7e89a81075d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45596b2dc3b59917dfbbf36d5b3d4816"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structsys__time.html">sys_time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga45596b2dc3b59917dfbbf36d5b3d4816">sys_time_t</a></td></tr>
<tr class="memdesc:ga45596b2dc3b59917dfbbf36d5b3d4816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a system time structure.  <a href="#ga45596b2dc3b59917dfbbf36d5b3d4816">More...</a><br /></td></tr>
<tr class="separator:ga45596b2dc3b59917dfbbf36d5b3d4816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3533996feca2a9c8233da4b172f4c007"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structsys__timer__t.html">sys_timer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga3533996feca2a9c8233da4b172f4c007">sys_timer_t</a></td></tr>
<tr class="memdesc:ga3533996feca2a9c8233da4b172f4c007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer context structure.  <a href="#ga3533996feca2a9c8233da4b172f4c007">More...</a><br /></td></tr>
<tr class="separator:ga3533996feca2a9c8233da4b172f4c007"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga3d01ed00e5a4f0a1c2ea0bbf5233e899"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga3d01ed00e5a4f0a1c2ea0bbf5233e899">sys_hash_algorithm_t</a> { <b>sys_hash_md5</b> = 1, 
<b>sys_hash_sha256</b>
 }<tr class="memdesc:ga3d01ed00e5a4f0a1c2ea0bbf5233e899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash algorithm identifiers.  <a href="group__System.html#ga3d01ed00e5a4f0a1c2ea0bbf5233e899">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga3d01ed00e5a4f0a1c2ea0bbf5233e899"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gadf5a5676c999a3f4e21608a21e7e636f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsys__event__queue__t.html">sys_event_queue_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#gadf5a5676c999a3f4e21608a21e7e636f">sys_event_queue_init</a> (size_t capacity)</td></tr>
<tr class="memdesc:gadf5a5676c999a3f4e21608a21e7e636f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a new event queue.  <a href="#gadf5a5676c999a3f4e21608a21e7e636f">More...</a><br /></td></tr>
<tr class="separator:gadf5a5676c999a3f4e21608a21e7e636f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4f27a3c63a3d274f23d4111dc05315a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#gab4f27a3c63a3d274f23d4111dc05315a">sys_event_queue_finalize</a> (<a class="el" href="structsys__event__queue__t.html">sys_event_queue_t</a> *queue)</td></tr>
<tr class="memdesc:gab4f27a3c63a3d274f23d4111dc05315a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize and cleanup an event queue.  <a href="#gab4f27a3c63a3d274f23d4111dc05315a">More...</a><br /></td></tr>
<tr class="separator:gab4f27a3c63a3d274f23d4111dc05315a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3b1d50d0e78404ebd74355a474fb10b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#gaf3b1d50d0e78404ebd74355a474fb10b">sys_event_queue_push</a> (<a class="el" href="structsys__event__queue__t.html">sys_event_queue_t</a> *queue, <a class="el" href="group__System.html#ga2bdd4be7e6e04b4ee95e0459ff001702">sys_event_t</a> event)</td></tr>
<tr class="memdesc:gaf3b1d50d0e78404ebd74355a474fb10b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push an event to the queue (always succeeds)  <a href="#gaf3b1d50d0e78404ebd74355a474fb10b">More...</a><br /></td></tr>
<tr class="separator:gaf3b1d50d0e78404ebd74355a474fb10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac876f605be4e2014ec50a51848d2bb21"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#gac876f605be4e2014ec50a51848d2bb21">sys_event_queue_try_push</a> (<a class="el" href="structsys__event__queue__t.html">sys_event_queue_t</a> *queue, <a class="el" href="group__System.html#ga2bdd4be7e6e04b4ee95e0459ff001702">sys_event_t</a> event)</td></tr>
<tr class="memdesc:gac876f605be4e2014ec50a51848d2bb21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to push an event without overwriting.  <a href="#gac876f605be4e2014ec50a51848d2bb21">More...</a><br /></td></tr>
<tr class="separator:gac876f605be4e2014ec50a51848d2bb21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fd435e560a0892a61851b0f66c56f9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__System.html#ga2bdd4be7e6e04b4ee95e0459ff001702">sys_event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga4fd435e560a0892a61851b0f66c56f9a">sys_event_queue_peek</a> (<a class="el" href="structsys__event__queue__t.html">sys_event_queue_t</a> *queue)</td></tr>
<tr class="memdesc:ga4fd435e560a0892a61851b0f66c56f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek at the next event without removing it.  <a href="#ga4fd435e560a0892a61851b0f66c56f9a">More...</a><br /></td></tr>
<tr class="separator:ga4fd435e560a0892a61851b0f66c56f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadce3a0a7f3b32706c7064e8659d52b21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__System.html#ga2bdd4be7e6e04b4ee95e0459ff001702">sys_event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#gadce3a0a7f3b32706c7064e8659d52b21">sys_event_queue_pop</a> (<a class="el" href="structsys__event__queue__t.html">sys_event_queue_t</a> *queue)</td></tr>
<tr class="memdesc:gadce3a0a7f3b32706c7064e8659d52b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove and return the next event (blocking)  <a href="#gadce3a0a7f3b32706c7064e8659d52b21">More...</a><br /></td></tr>
<tr class="separator:gadce3a0a7f3b32706c7064e8659d52b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37045eb6c48834403c8fc2bbafa5e202"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__System.html#ga2bdd4be7e6e04b4ee95e0459ff001702">sys_event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga37045eb6c48834403c8fc2bbafa5e202">sys_event_queue_try_pop</a> (<a class="el" href="structsys__event__queue__t.html">sys_event_queue_t</a> *queue)</td></tr>
<tr class="memdesc:ga37045eb6c48834403c8fc2bbafa5e202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to remove and return the next event (non-blocking)  <a href="#ga37045eb6c48834403c8fc2bbafa5e202">More...</a><br /></td></tr>
<tr class="separator:ga37045eb6c48834403c8fc2bbafa5e202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad09cd8375749826b96633ff0d138902b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__System.html#ga2bdd4be7e6e04b4ee95e0459ff001702">sys_event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#gad09cd8375749826b96633ff0d138902b">sys_event_queue_timed_pop</a> (<a class="el" href="structsys__event__queue__t.html">sys_event_queue_t</a> *queue, uint32_t timeout_ms)</td></tr>
<tr class="memdesc:gad09cd8375749826b96633ff0d138902b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove and return the next event with timeout.  <a href="#gad09cd8375749826b96633ff0d138902b">More...</a><br /></td></tr>
<tr class="separator:gad09cd8375749826b96633ff0d138902b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ca657c0597f3133a202f68c7f91f6fd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga0ca657c0597f3133a202f68c7f91f6fd">sys_event_queue_size</a> (<a class="el" href="structsys__event__queue__t.html">sys_event_queue_t</a> *queue)</td></tr>
<tr class="memdesc:ga0ca657c0597f3133a202f68c7f91f6fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current number of events in the queue.  <a href="#ga0ca657c0597f3133a202f68c7f91f6fd">More...</a><br /></td></tr>
<tr class="separator:ga0ca657c0597f3133a202f68c7f91f6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8c695090d16fb853c6289a21c2db91b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#gad8c695090d16fb853c6289a21c2db91b">sys_event_queue_empty</a> (<a class="el" href="structsys__event__queue__t.html">sys_event_queue_t</a> *queue)</td></tr>
<tr class="memdesc:gad8c695090d16fb853c6289a21c2db91b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the queue is empty.  <a href="#gad8c695090d16fb853c6289a21c2db91b">More...</a><br /></td></tr>
<tr class="separator:gad8c695090d16fb853c6289a21c2db91b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac94e5bdf92c1b596445730c992e27c60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#gac94e5bdf92c1b596445730c992e27c60">sys_event_queue_shutdown</a> (<a class="el" href="structsys__event__queue__t.html">sys_event_queue_t</a> *queue)</td></tr>
<tr class="memdesc:gac94e5bdf92c1b596445730c992e27c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shut down the queue gracefully.  <a href="#gac94e5bdf92c1b596445730c992e27c60">More...</a><br /></td></tr>
<tr class="separator:gac94e5bdf92c1b596445730c992e27c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e1bf7986654d89f6debd775158dc685"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga2e1bf7986654d89f6debd775158dc685">sys_event_queue_lock</a> (<a class="el" href="structsys__event__queue__t.html">sys_event_queue_t</a> *queue)</td></tr>
<tr class="memdesc:ga2e1bf7986654d89f6debd775158dc685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the queue for manual synchronization.  <a href="#ga2e1bf7986654d89f6debd775158dc685">More...</a><br /></td></tr>
<tr class="separator:ga2e1bf7986654d89f6debd775158dc685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebe7204ad57c101cbbb0eb1ccef42168"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#gaebe7204ad57c101cbbb0eb1ccef42168">sys_event_queue_unlock</a> (<a class="el" href="structsys__event__queue__t.html">sys_event_queue_t</a> *queue)</td></tr>
<tr class="memdesc:gaebe7204ad57c101cbbb0eb1ccef42168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the queue after manual synchronization.  <a href="#gaebe7204ad57c101cbbb0eb1ccef42168">More...</a><br /></td></tr>
<tr class="separator:gaebe7204ad57c101cbbb0eb1ccef42168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11ae4ec7ba4ce8204080783ec4820165"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsys__hash__t.html">sys_hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga11ae4ec7ba4ce8204080783ec4820165">sys_hash_init</a> (<a class="el" href="group__System.html#ga3d01ed00e5a4f0a1c2ea0bbf5233e899">sys_hash_algorithm_t</a> algorithm)</td></tr>
<tr class="memdesc:ga11ae4ec7ba4ce8204080783ec4820165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new hash context for the specified algorithm.  <a href="#ga11ae4ec7ba4ce8204080783ec4820165">More...</a><br /></td></tr>
<tr class="separator:ga11ae4ec7ba4ce8204080783ec4820165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad03b5376d31a464be04db43aa371413b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#gad03b5376d31a464be04db43aa371413b">sys_hash_size</a> (<a class="el" href="structsys__hash__t.html">sys_hash_t</a> *hash)</td></tr>
<tr class="memdesc:gad03b5376d31a464be04db43aa371413b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the hash in bytes.  <a href="#gad03b5376d31a464be04db43aa371413b">More...</a><br /></td></tr>
<tr class="separator:gad03b5376d31a464be04db43aa371413b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64b3413178b06e7e85604dd32f27d1a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga64b3413178b06e7e85604dd32f27d1a5">sys_hash_update</a> (<a class="el" href="structsys__hash__t.html">sys_hash_t</a> *hash, const void *data, size_t size)</td></tr>
<tr class="memdesc:ga64b3413178b06e7e85604dd32f27d1a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the hash context with new data.  <a href="#ga64b3413178b06e7e85604dd32f27d1a5">More...</a><br /></td></tr>
<tr class="separator:ga64b3413178b06e7e85604dd32f27d1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga991bebea4457d3b1ee1fecc326e8186c"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga991bebea4457d3b1ee1fecc326e8186c">sys_hash_finalize</a> (<a class="el" href="structsys__hash__t.html">sys_hash_t</a> *hash)</td></tr>
<tr class="memdesc:ga991bebea4457d3b1ee1fecc326e8186c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes the hash computation and returns the hash value.  <a href="#ga991bebea4457d3b1ee1fecc326e8186c">More...</a><br /></td></tr>
<tr class="separator:ga991bebea4457d3b1ee1fecc326e8186c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6120ff4195b27fbb71b2fa7e5ddb29c3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga6120ff4195b27fbb71b2fa7e5ddb29c3">sys_malloc</a> (size_t size)</td></tr>
<tr class="memdesc:ga6120ff4195b27fbb71b2fa7e5ddb29c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a block of memory.  <a href="#ga6120ff4195b27fbb71b2fa7e5ddb29c3">More...</a><br /></td></tr>
<tr class="separator:ga6120ff4195b27fbb71b2fa7e5ddb29c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b1ddbaf824f0a7fb7292c26883fd061"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga0b1ddbaf824f0a7fb7292c26883fd061">sys_free</a> (void *ptr)</td></tr>
<tr class="memdesc:ga0b1ddbaf824f0a7fb7292c26883fd061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a block of memory.  <a href="#ga0b1ddbaf824f0a7fb7292c26883fd061">More...</a><br /></td></tr>
<tr class="separator:ga0b1ddbaf824f0a7fb7292c26883fd061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf09714d849584f8d9866562a2b65c06e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#gaf09714d849584f8d9866562a2b65c06e">sys_memset</a> (void *ptr, uint8_t value, size_t size)</td></tr>
<tr class="memdesc:gaf09714d849584f8d9866562a2b65c06e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set memory to a specific value.  <a href="#gaf09714d849584f8d9866562a2b65c06e">More...</a><br /></td></tr>
<tr class="separator:gaf09714d849584f8d9866562a2b65c06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3eb9d4345a9504a321b577c12fd115fa"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga3eb9d4345a9504a321b577c12fd115fa">sys_memcpy</a> (void *dest, const void *src, size_t size)</td></tr>
<tr class="memdesc:ga3eb9d4345a9504a321b577c12fd115fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy memory from source to destination.  <a href="#ga3eb9d4345a9504a321b577c12fd115fa">More...</a><br /></td></tr>
<tr class="separator:ga3eb9d4345a9504a321b577c12fd115fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5072718fc98e368bb925c0f746a1ae6b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga5072718fc98e368bb925c0f746a1ae6b">sys_memmove</a> (void *dest, const void *src, size_t size)</td></tr>
<tr class="memdesc:ga5072718fc98e368bb925c0f746a1ae6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move memory from source to destination (handles overlapping regions)  <a href="#ga5072718fc98e368bb925c0f746a1ae6b">More...</a><br /></td></tr>
<tr class="separator:ga5072718fc98e368bb925c0f746a1ae6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77f042ac51dec1bb8b23525569b3f777"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga77f042ac51dec1bb8b23525569b3f777">sys_memcmp</a> (const void *ptr1, const void *ptr2, size_t num)</td></tr>
<tr class="memdesc:ga77f042ac51dec1bb8b23525569b3f777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two memory blocks.  <a href="#ga77f042ac51dec1bb8b23525569b3f777">More...</a><br /></td></tr>
<tr class="separator:ga77f042ac51dec1bb8b23525569b3f777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6bda746d6b03c697ebcf468f83fdb6d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#gab6bda746d6b03c697ebcf468f83fdb6d">sys_printf</a> (const char *format,...)</td></tr>
<tr class="memdesc:gab6bda746d6b03c697ebcf468f83fdb6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints formatted output to the system console.  <a href="#gab6bda746d6b03c697ebcf468f83fdb6d">More...</a><br /></td></tr>
<tr class="separator:gab6bda746d6b03c697ebcf468f83fdb6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac71469c45207a063e75bf7e6c2dbb5b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#gaac71469c45207a063e75bf7e6c2dbb5b">sys_vprintf</a> (const char *format, va_list args)</td></tr>
<tr class="memdesc:gaac71469c45207a063e75bf7e6c2dbb5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints formatted output using a va_list argument.  <a href="#gaac71469c45207a063e75bf7e6c2dbb5b">More...</a><br /></td></tr>
<tr class="separator:gaac71469c45207a063e75bf7e6c2dbb5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga340ab3d1b3e0cef587d52b580cd59d25"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga340ab3d1b3e0cef587d52b580cd59d25">sys_sprintf</a> (char *buf, size_t sz, const char *format,...)</td></tr>
<tr class="memdesc:ga340ab3d1b3e0cef587d52b580cd59d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints formatted output to a string buffer.  <a href="#ga340ab3d1b3e0cef587d52b580cd59d25">More...</a><br /></td></tr>
<tr class="separator:ga340ab3d1b3e0cef587d52b580cd59d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86745087b8aeeae5c0715896240ab992"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga86745087b8aeeae5c0715896240ab992">sys_vsprintf</a> (char *buf, size_t sz, const char *format, va_list args)</td></tr>
<tr class="memdesc:ga86745087b8aeeae5c0715896240ab992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints formatted output to a string buffer using a va_list argument.  <a href="#ga86745087b8aeeae5c0715896240ab992">More...</a><br /></td></tr>
<tr class="separator:ga86745087b8aeeae5c0715896240ab992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39c02847b060cfe7b9c568a06bc7ad74"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga39c02847b060cfe7b9c568a06bc7ad74">sys_random_uint32</a> (void)</td></tr>
<tr class="memdesc:ga39c02847b060cfe7b9c568a06bc7ad74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random number as a 32-bit unsigned integer.  <a href="#ga39c02847b060cfe7b9c568a06bc7ad74">More...</a><br /></td></tr>
<tr class="separator:ga39c02847b060cfe7b9c568a06bc7ad74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fce61e0b72cfddf664a85be328cddab"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga2fce61e0b72cfddf664a85be328cddab">sys_random_uint64</a> (void)</td></tr>
<tr class="memdesc:ga2fce61e0b72cfddf664a85be328cddab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random number as a 64-bit unsigned integer.  <a href="#ga2fce61e0b72cfddf664a85be328cddab">More...</a><br /></td></tr>
<tr class="separator:ga2fce61e0b72cfddf664a85be328cddab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57eff626a70b50a6dd10fb2893a1dc2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsys__mutex__t.html">sys_mutex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga57eff626a70b50a6dd10fb2893a1dc2e">sys_mutex_init</a> (void)</td></tr>
<tr class="memdesc:ga57eff626a70b50a6dd10fb2893a1dc2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a new mutex.  <a href="#ga57eff626a70b50a6dd10fb2893a1dc2e">More...</a><br /></td></tr>
<tr class="separator:ga57eff626a70b50a6dd10fb2893a1dc2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga138955bcde069851868561cd20fb876a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga138955bcde069851868561cd20fb876a">sys_mutex_lock</a> (<a class="el" href="structsys__mutex__t.html">sys_mutex_t</a> *mutex)</td></tr>
<tr class="memdesc:ga138955bcde069851868561cd20fb876a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock a mutex, by blocking.  <a href="#ga138955bcde069851868561cd20fb876a">More...</a><br /></td></tr>
<tr class="separator:ga138955bcde069851868561cd20fb876a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec452afb418073c5212e6f9abdcedfe1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#gaec452afb418073c5212e6f9abdcedfe1">sys_mutex_trylock</a> (<a class="el" href="structsys__mutex__t.html">sys_mutex_t</a> *mutex)</td></tr>
<tr class="memdesc:gaec452afb418073c5212e6f9abdcedfe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to lock a mutex.  <a href="#gaec452afb418073c5212e6f9abdcedfe1">More...</a><br /></td></tr>
<tr class="separator:gaec452afb418073c5212e6f9abdcedfe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c24c3cfd80c2e2b8963aec0b895fe3d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga7c24c3cfd80c2e2b8963aec0b895fe3d">sys_mutex_unlock</a> (<a class="el" href="structsys__mutex__t.html">sys_mutex_t</a> *mutex)</td></tr>
<tr class="memdesc:ga7c24c3cfd80c2e2b8963aec0b895fe3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock a mutex.  <a href="#ga7c24c3cfd80c2e2b8963aec0b895fe3d">More...</a><br /></td></tr>
<tr class="separator:ga7c24c3cfd80c2e2b8963aec0b895fe3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaeb0d92904b70d289a5f4a6a5f93c76a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#gaaeb0d92904b70d289a5f4a6a5f93c76a">sys_mutex_finalize</a> (<a class="el" href="structsys__mutex__t.html">sys_mutex_t</a> *mutex)</td></tr>
<tr class="memdesc:gaaeb0d92904b70d289a5f4a6a5f93c76a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize and cleanup a mutex.  <a href="#gaaeb0d92904b70d289a5f4a6a5f93c76a">More...</a><br /></td></tr>
<tr class="separator:gaaeb0d92904b70d289a5f4a6a5f93c76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e809159c9598f61c5eb36a6c5e5b040"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsys__cond__t.html">sys_cond_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga3e809159c9598f61c5eb36a6c5e5b040">sys_cond_init</a> (void)</td></tr>
<tr class="memdesc:ga3e809159c9598f61c5eb36a6c5e5b040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a new condition variable.  <a href="#ga3e809159c9598f61c5eb36a6c5e5b040">More...</a><br /></td></tr>
<tr class="separator:ga3e809159c9598f61c5eb36a6c5e5b040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6b426975c75bfd913e4ed517314a036"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#gad6b426975c75bfd913e4ed517314a036">sys_cond_wait</a> (<a class="el" href="structsys__cond__t.html">sys_cond_t</a> *cond, <a class="el" href="structsys__mutex__t.html">sys_mutex_t</a> *mutex)</td></tr>
<tr class="memdesc:gad6b426975c75bfd913e4ed517314a036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait on a condition variable.  <a href="#gad6b426975c75bfd913e4ed517314a036">More...</a><br /></td></tr>
<tr class="separator:gad6b426975c75bfd913e4ed517314a036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13ddb102887ad005fb1c7406eb6d62df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga13ddb102887ad005fb1c7406eb6d62df">sys_cond_timedwait</a> (<a class="el" href="structsys__cond__t.html">sys_cond_t</a> *cond, <a class="el" href="structsys__mutex__t.html">sys_mutex_t</a> *mutex, uint32_t timeout_ms)</td></tr>
<tr class="memdesc:ga13ddb102887ad005fb1c7406eb6d62df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait on a condition variable with timeout.  <a href="#ga13ddb102887ad005fb1c7406eb6d62df">More...</a><br /></td></tr>
<tr class="separator:ga13ddb102887ad005fb1c7406eb6d62df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf21f413d7edc81444bf3e908cbe4e867"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#gaf21f413d7edc81444bf3e908cbe4e867">sys_cond_signal</a> (<a class="el" href="structsys__cond__t.html">sys_cond_t</a> *cond)</td></tr>
<tr class="memdesc:gaf21f413d7edc81444bf3e908cbe4e867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal one waiting thread.  <a href="#gaf21f413d7edc81444bf3e908cbe4e867">More...</a><br /></td></tr>
<tr class="separator:gaf21f413d7edc81444bf3e908cbe4e867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2f90e7a405742e4b0b01e9379a5b001"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#gad2f90e7a405742e4b0b01e9379a5b001">sys_cond_broadcast</a> (<a class="el" href="structsys__cond__t.html">sys_cond_t</a> *cond)</td></tr>
<tr class="memdesc:gad2f90e7a405742e4b0b01e9379a5b001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal all waiting threads.  <a href="#gad2f90e7a405742e4b0b01e9379a5b001">More...</a><br /></td></tr>
<tr class="separator:gad2f90e7a405742e4b0b01e9379a5b001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga024d585a2ba4843ecef30a71a3b56aa7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga024d585a2ba4843ecef30a71a3b56aa7">sys_cond_finalize</a> (<a class="el" href="structsys__cond__t.html">sys_cond_t</a> *cond)</td></tr>
<tr class="memdesc:ga024d585a2ba4843ecef30a71a3b56aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize and cleanup a condition variable.  <a href="#ga024d585a2ba4843ecef30a71a3b56aa7">More...</a><br /></td></tr>
<tr class="separator:ga024d585a2ba4843ecef30a71a3b56aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga054b7429932a28dd301dacca5adb97e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsys__waitgroup__t.html">sys_waitgroup_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga054b7429932a28dd301dacca5adb97e5">sys_waitgroup_init</a> (void)</td></tr>
<tr class="memdesc:ga054b7429932a28dd301dacca5adb97e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a new waitgroup.  <a href="#ga054b7429932a28dd301dacca5adb97e5">More...</a><br /></td></tr>
<tr class="separator:ga054b7429932a28dd301dacca5adb97e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fe6dc303b2686856f6496f8c3589eeb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga6fe6dc303b2686856f6496f8c3589eeb">sys_waitgroup_add</a> (<a class="el" href="structsys__waitgroup__t.html">sys_waitgroup_t</a> *wg, int delta)</td></tr>
<tr class="memdesc:ga6fe6dc303b2686856f6496f8c3589eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to the waitgroup counter.  <a href="#ga6fe6dc303b2686856f6496f8c3589eeb">More...</a><br /></td></tr>
<tr class="separator:ga6fe6dc303b2686856f6496f8c3589eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bc3531da1d947e8b588749cecc2b692"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga6bc3531da1d947e8b588749cecc2b692">sys_waitgroup_done</a> (<a class="el" href="structsys__waitgroup__t.html">sys_waitgroup_t</a> *wg)</td></tr>
<tr class="memdesc:ga6bc3531da1d947e8b588749cecc2b692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement the waitgroup counter.  <a href="#ga6bc3531da1d947e8b588749cecc2b692">More...</a><br /></td></tr>
<tr class="separator:ga6bc3531da1d947e8b588749cecc2b692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabca9a01a0834ad14251f39c45a1120d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#gabca9a01a0834ad14251f39c45a1120d6">sys_waitgroup_finalize</a> (<a class="el" href="structsys__waitgroup__t.html">sys_waitgroup_t</a> *wg)</td></tr>
<tr class="memdesc:gabca9a01a0834ad14251f39c45a1120d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize and cleanup a waitgroup - wait for completion then cleanup.  <a href="#gabca9a01a0834ad14251f39c45a1120d6">More...</a><br /></td></tr>
<tr class="separator:gabca9a01a0834ad14251f39c45a1120d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4eced11c2352451c4ea6c7386e58342b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga4eced11c2352451c4ea6c7386e58342b">sys_puts</a> (const char *str)</td></tr>
<tr class="memdesc:ga4eced11c2352451c4ea6c7386e58342b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a string to the system console or standard output.  <a href="#ga4eced11c2352451c4ea6c7386e58342b">More...</a><br /></td></tr>
<tr class="separator:ga4eced11c2352451c4ea6c7386e58342b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae13dd8a6d75ee7e807c43ae84ec66dfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#gae13dd8a6d75ee7e807c43ae84ec66dfd">sys_putch</a> (const char ch)</td></tr>
<tr class="memdesc:gae13dd8a6d75ee7e807c43ae84ec66dfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a character to the system console or standard output.  <a href="#gae13dd8a6d75ee7e807c43ae84ec66dfd">More...</a><br /></td></tr>
<tr class="separator:gae13dd8a6d75ee7e807c43ae84ec66dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf411a8bc6b7ed4b0af9114e10c959448"><td class="memItemLeft" align="right" valign="top"><a id="gaf411a8bc6b7ed4b0af9114e10c959448"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#gaf411a8bc6b7ed4b0af9114e10c959448">sys_init</a> (void)</td></tr>
<tr class="memdesc:gaf411a8bc6b7ed4b0af9114e10c959448"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the system on startup. <br /></td></tr>
<tr class="separator:gaf411a8bc6b7ed4b0af9114e10c959448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8c2364fd51221e5ac983f174aeb289f"><td class="memItemLeft" align="right" valign="top"><a id="gac8c2364fd51221e5ac983f174aeb289f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#gac8c2364fd51221e5ac983f174aeb289f">sys_exit</a> (void)</td></tr>
<tr class="memdesc:gac8c2364fd51221e5ac983f174aeb289f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans up the system on shutdown. <br /></td></tr>
<tr class="separator:gac8c2364fd51221e5ac983f174aeb289f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51400f71e4702fdbd13394546f4182bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga51400f71e4702fdbd13394546f4182bb">sys_abort</a> (void)</td></tr>
<tr class="memdesc:ga51400f71e4702fdbd13394546f4182bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts the current process immediately.  <a href="#ga51400f71e4702fdbd13394546f4182bb">More...</a><br /></td></tr>
<tr class="separator:ga51400f71e4702fdbd13394546f4182bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga795b667df1ea24eeb5045a9f625f8611"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga795b667df1ea24eeb5045a9f625f8611">sys_panicf</a> (const char *fmt,...)</td></tr>
<tr class="memdesc:ga795b667df1ea24eeb5045a9f625f8611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a formatted panic message and aborts the process.  <a href="#ga795b667df1ea24eeb5045a9f625f8611">More...</a><br /></td></tr>
<tr class="separator:ga795b667df1ea24eeb5045a9f625f8611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd9cf2d40386c9cef130e39d39155293"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#gafd9cf2d40386c9cef130e39d39155293">sys_thread_numcores</a> (void)</td></tr>
<tr class="memdesc:gafd9cf2d40386c9cef130e39d39155293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of CPU cores available on the host system.  <a href="#gafd9cf2d40386c9cef130e39d39155293">More...</a><br /></td></tr>
<tr class="separator:gafd9cf2d40386c9cef130e39d39155293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga677402551d5d11b4e3ee60391d5a4faf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga677402551d5d11b4e3ee60391d5a4faf">sys_thread_create</a> (<a class="el" href="group__System.html#ga44d92420e9c1148c746ce7e89a81075d">sys_thread_func_t</a> func, void *arg)</td></tr>
<tr class="memdesc:ga677402551d5d11b4e3ee60391d5a4faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a thread on any available core.  <a href="#ga677402551d5d11b4e3ee60391d5a4faf">More...</a><br /></td></tr>
<tr class="separator:ga677402551d5d11b4e3ee60391d5a4faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b72ef6424828a90881daa3559864cf4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga1b72ef6424828a90881daa3559864cf4">sys_thread_create_on_core</a> (<a class="el" href="group__System.html#ga44d92420e9c1148c746ce7e89a81075d">sys_thread_func_t</a> func, void *arg, uint8_t core)</td></tr>
<tr class="memdesc:ga1b72ef6424828a90881daa3559864cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a thread on a specific core.  <a href="#ga1b72ef6424828a90881daa3559864cf4">More...</a><br /></td></tr>
<tr class="separator:ga1b72ef6424828a90881daa3559864cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c6d6105e812d597fd8457f1d79290cc"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga4c6d6105e812d597fd8457f1d79290cc">sys_thread_core</a> (void)</td></tr>
<tr class="memdesc:ga4c6d6105e812d597fd8457f1d79290cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the CPU core number the current thread is running on.  <a href="#ga4c6d6105e812d597fd8457f1d79290cc">More...</a><br /></td></tr>
<tr class="separator:ga4c6d6105e812d597fd8457f1d79290cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb5a950a99bad2a938dee8c861e50269"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#gacb5a950a99bad2a938dee8c861e50269">sys_sleep</a> (int32_t msec)</td></tr>
<tr class="memdesc:gacb5a950a99bad2a938dee8c861e50269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pauses the execution of the current thread for a specified time.  <a href="#gacb5a950a99bad2a938dee8c861e50269">More...</a><br /></td></tr>
<tr class="separator:gacb5a950a99bad2a938dee8c861e50269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f593b86e80e479fff851b0b0c715da0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga0f593b86e80e479fff851b0b0c715da0">sys_time_get_utc</a> (<a class="el" href="group__System.html#ga45596b2dc3b59917dfbbf36d5b3d4816">sys_time_t</a> *time)</td></tr>
<tr class="memdesc:ga0f593b86e80e479fff851b0b0c715da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current UTC time.  <a href="#ga0f593b86e80e479fff851b0b0c715da0">More...</a><br /></td></tr>
<tr class="separator:ga0f593b86e80e479fff851b0b0c715da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga664e2499cff45dfad7da8a16ad873dfd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga664e2499cff45dfad7da8a16ad873dfd">sys_time_get_time_utc</a> (<a class="el" href="group__System.html#ga45596b2dc3b59917dfbbf36d5b3d4816">sys_time_t</a> *time, uint8_t *hours, uint8_t *minutes, uint8_t *seconds)</td></tr>
<tr class="memdesc:ga664e2499cff45dfad7da8a16ad873dfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts time components from a sys_time_t structure.  <a href="#ga664e2499cff45dfad7da8a16ad873dfd">More...</a><br /></td></tr>
<tr class="separator:ga664e2499cff45dfad7da8a16ad873dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34afa8ff2a90627f3119d0fe662fdb89"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga34afa8ff2a90627f3119d0fe662fdb89">sys_time_get_date_utc</a> (<a class="el" href="group__System.html#ga45596b2dc3b59917dfbbf36d5b3d4816">sys_time_t</a> *time, uint16_t *year, uint8_t *month, uint8_t *day, uint8_t *weekday)</td></tr>
<tr class="memdesc:ga34afa8ff2a90627f3119d0fe662fdb89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts date components from a sys_time_t structure.  <a href="#ga34afa8ff2a90627f3119d0fe662fdb89">More...</a><br /></td></tr>
<tr class="separator:ga34afa8ff2a90627f3119d0fe662fdb89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga172740122067a523d9d32478126db59b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga172740122067a523d9d32478126db59b">sys_time_set_time_utc</a> (<a class="el" href="group__System.html#ga45596b2dc3b59917dfbbf36d5b3d4816">sys_time_t</a> *time, uint8_t hours, uint8_t minutes, uint8_t seconds)</td></tr>
<tr class="memdesc:ga172740122067a523d9d32478126db59b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets time components in a sys_time_t structure, preserving the date.  <a href="#ga172740122067a523d9d32478126db59b">More...</a><br /></td></tr>
<tr class="separator:ga172740122067a523d9d32478126db59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad6616ff63c8cbdbaf3fd97697bb074c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#gaad6616ff63c8cbdbaf3fd97697bb074c">sys_time_set_date_utc</a> (<a class="el" href="group__System.html#ga45596b2dc3b59917dfbbf36d5b3d4816">sys_time_t</a> *time, uint16_t year, uint8_t month, uint8_t day)</td></tr>
<tr class="memdesc:gaad6616ff63c8cbdbaf3fd97697bb074c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets date components in a sys_time_t structure, preserving the time.  <a href="#gaad6616ff63c8cbdbaf3fd97697bb074c">More...</a><br /></td></tr>
<tr class="separator:gaad6616ff63c8cbdbaf3fd97697bb074c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ca6ec26efbd88031d42509a07482f3d"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga4ca6ec26efbd88031d42509a07482f3d">sys_time_compare_ns</a> (const <a class="el" href="group__System.html#ga45596b2dc3b59917dfbbf36d5b3d4816">sys_time_t</a> *start, const <a class="el" href="group__System.html#ga45596b2dc3b59917dfbbf36d5b3d4816">sys_time_t</a> *end)</td></tr>
<tr class="memdesc:ga4ca6ec26efbd88031d42509a07482f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the difference in nanoseconds between two sys_time_t structures.  <a href="#ga4ca6ec26efbd88031d42509a07482f3d">More...</a><br /></td></tr>
<tr class="separator:ga4ca6ec26efbd88031d42509a07482f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1368a749ee9713f5339cfc2b27dbdcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsys__timer__t.html">sys_timer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#gac1368a749ee9713f5339cfc2b27dbdcd">sys_timer_init</a> (uint32_t interval_ms, void *userdata, void(*callback)(<a class="el" href="structsys__timer__t.html">sys_timer_t</a> *))</td></tr>
<tr class="memdesc:gac1368a749ee9713f5339cfc2b27dbdcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new timer context.  <a href="#gac1368a749ee9713f5339cfc2b27dbdcd">More...</a><br /></td></tr>
<tr class="separator:gac1368a749ee9713f5339cfc2b27dbdcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0aeeb7a38cc0c6e93ff30bf1ed6f4772"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga0aeeb7a38cc0c6e93ff30bf1ed6f4772">sys_timer_start</a> (<a class="el" href="structsys__timer__t.html">sys_timer_t</a> *timer)</td></tr>
<tr class="memdesc:ga0aeeb7a38cc0c6e93ff30bf1ed6f4772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a timer.  <a href="#ga0aeeb7a38cc0c6e93ff30bf1ed6f4772">More...</a><br /></td></tr>
<tr class="separator:ga0aeeb7a38cc0c6e93ff30bf1ed6f4772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03c3073fd8f641e7cea076652bbe11dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System.html#ga03c3073fd8f641e7cea076652bbe11dd">sys_timer_finalize</a> (<a class="el" href="structsys__timer__t.html">sys_timer_t</a> *timer)</td></tr>
<tr class="memdesc:ga03c3073fd8f641e7cea076652bbe11dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancels and finalizes a timer.  <a href="#ga03c3073fd8f641e7cea076652bbe11dd">More...</a><br /></td></tr>
<tr class="separator:ga03c3073fd8f641e7cea076652bbe11dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>System methods for managing memory, threads and resources. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga17b5573319cb8e7d1a7afdeae1a657a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17b5573319cb8e7d1a7afdeae1a657a9">&#9670;&nbsp;</a></span>SYS_HASH_CTX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYS_HASH_CTX_SIZE&#160;&#160;&#160;128</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of the hash context buffer. </p>
<p>This defines the size of the context buffer used for hash operations. It should be large enough to hold any hash algorithm's context. </p>

<p class="definition">Definition at line <a class="el" href="hash_8h_source.html#l00033">33</a> of file <a class="el" href="hash_8h_source.html">hash.h</a>.</p>

</div>
</div>
<a id="ga3700f36a38e34fc20ed338df76692bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3700f36a38e34fc20ed338df76692bab">&#9670;&nbsp;</a></span>SYS_HASH_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYS_HASH_SIZE&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of the hash. </p>
<p>This defines the size of the hash value produced by the hash operations. It should be large enough to hold any hash algorithm's output. </p>

<p class="definition">Definition at line <a class="el" href="hash_8h_source.html#l00024">24</a> of file <a class="el" href="hash_8h_source.html">hash.h</a>.</p>

</div>
</div>
<a id="ga208fc3368b9e3ed3d9d22e9be875731e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga208fc3368b9e3ed3d9d22e9be875731e">&#9670;&nbsp;</a></span>SYS_TIMER_CTX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYS_TIMER_CTX_SIZE&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of the timer context buffer. </p>
<p>This defines the size of the context buffer used for timer operations. It should be large enough to hold any platform-specific timer context. </p>

<p class="definition">Definition at line <a class="el" href="timer_8h_source.html#l00028">28</a> of file <a class="el" href="timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga2bdd4be7e6e04b4ee95e0459ff001702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bdd4be7e6e04b4ee95e0459ff001702">&#9670;&nbsp;</a></span>sys_event_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="group__System.html#ga2bdd4be7e6e04b4ee95e0459ff001702">sys_event_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event type for queue items. </p>
<p>Simple event type that can hold any pointer data. This can be enhanced in the future to include metadata like timestamps, priorities, etc. </p>

<p class="definition">Definition at line <a class="el" href="event_8h_source.html#l00033">33</a> of file <a class="el" href="event_8h_source.html">event.h</a>.</p>

</div>
</div>
<a id="ga44d92420e9c1148c746ce7e89a81075d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44d92420e9c1148c746ce7e89a81075d">&#9670;&nbsp;</a></span>sys_thread_func_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* sys_thread_func_t) (void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread function signatureFunction signature for thread entry points. </p>
<p>The function receives a single void pointer argument and should not return a value. The thread terminates when this function returns. </p>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00027">27</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="ga45596b2dc3b59917dfbbf36d5b3d4816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45596b2dc3b59917dfbbf36d5b3d4816">&#9670;&nbsp;</a></span>sys_time_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structsys__time.html">sys_time</a>  <a class="el" href="group__System.html#ga45596b2dc3b59917dfbbf36d5b3d4816">sys_time_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents a system time structure. </p>
<p>This structure is used to represent time in the system, including the current UTC time with nanosecond precision. Timezones are not included in this structure at the moment. </p>

</div>
</div>
<a id="ga3533996feca2a9c8233da4b172f4c007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3533996feca2a9c8233da4b172f4c007">&#9670;&nbsp;</a></span>sys_timer_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structsys__timer__t.html">sys_timer_t</a>  <a class="el" href="structsys__timer__t.html">sys_timer_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timer context structure. </p>
<p>Contains the state and configuration for timer operations. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga3d01ed00e5a4f0a1c2ea0bbf5233e899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d01ed00e5a4f0a1c2ea0bbf5233e899">&#9670;&nbsp;</a></span>sys_hash_algorithm_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__System.html#ga3d01ed00e5a4f0a1c2ea0bbf5233e899">sys_hash_algorithm_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hash algorithm identifiers. </p>
<p>Enumeration of supported cryptographic hash algorithms. </p>

<p class="definition">Definition at line <a class="el" href="hash_8h_source.html#l00041">41</a> of file <a class="el" href="hash_8h_source.html">hash.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;             {</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;  sys_hash_md5 = 1, <span class="comment">// MD5 hash (128-bit)</span></div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;  sys_hash_sha256,  <span class="comment">// SHA-256 hash (256-bit)</span></div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;} <a class="code" href="group__System.html#ga3d01ed00e5a4f0a1c2ea0bbf5233e899">sys_hash_algorithm_t</a>;</div><div class="ttc" id="group__System_html_ga3d01ed00e5a4f0a1c2ea0bbf5233e899"><div class="ttname"><a href="group__System.html#ga3d01ed00e5a4f0a1c2ea0bbf5233e899">sys_hash_algorithm_t</a></div><div class="ttdeci">sys_hash_algorithm_t</div><div class="ttdoc">Hash algorithm identifiers. </div><div class="ttdef"><b>Definition:</b> <a href="hash_8h_source.html#l00041">hash.h:41</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga51400f71e4702fdbd13394546f4182bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51400f71e4702fdbd13394546f4182bb">&#9670;&nbsp;</a></span>sys_abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_abort </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aborts the current process immediately. </p>
<dl class="section note"><dt>Note</dt><dd>This function does not return to the caller.</dd></dl>
<p>This function terminates the current process abnormally and immediately. It does not perform any cleanup operations and does not call exit handlers or destructors. </p>

</div>
</div>
<a id="gad2f90e7a405742e4b0b01e9379a5b001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2f90e7a405742e4b0b01e9379a5b001">&#9670;&nbsp;</a></span>sys_cond_broadcast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sys_cond_broadcast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__cond__t.html">sys_cond_t</a> *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal all waiting threads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>Pointer to the condition variable to broadcast </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false on error</dd></dl>
<p>Wakes up all threads waiting on the condition variable. If no threads are waiting, this function has no effect. The associated mutex should be locked when calling this function for predictable behavior. </p>

</div>
</div>
<a id="ga024d585a2ba4843ecef30a71a3b56aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga024d585a2ba4843ecef30a71a3b56aa7">&#9670;&nbsp;</a></span>sys_cond_finalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_cond_finalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__cond__t.html">sys_cond_t</a> *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize and cleanup a condition variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>Pointer to the condition variable to finalize</td></tr>
  </table>
  </dd>
</dl>
<p>Releases all resources associated with the condition variable and renders it unusable. No threads should be waiting on the condition variable when this function is called. </p>

</div>
</div>
<a id="ga3e809159c9598f61c5eb36a6c5e5b040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e809159c9598f61c5eb36a6c5e5b040">&#9670;&nbsp;</a></span>sys_cond_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsys__cond__t.html">sys_cond_t</a> sys_cond_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a new condition variable. </p>
<dl class="section return"><dt>Returns</dt><dd>Initialized condition variable structure</dd></dl>
<p>Creates and initializes a new condition variable for thread synchronization. The condition variable is ready for use with wait/signal operations. The returned condition variable must be finalized with <a class="el" href="group__System.html#ga024d585a2ba4843ecef30a71a3b56aa7" title="Finalize and cleanup a condition variable. ">sys_cond_finalize()</a> </p>

</div>
</div>
<a id="gaf21f413d7edc81444bf3e908cbe4e867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf21f413d7edc81444bf3e908cbe4e867">&#9670;&nbsp;</a></span>sys_cond_signal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sys_cond_signal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__cond__t.html">sys_cond_t</a> *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal one waiting thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>Pointer to the condition variable to signal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false on error</dd></dl>
<p>Wakes up one thread waiting on the condition variable. If no threads are waiting, this function has no effect. The associated mutex should be locked when calling this function for predictable behavior. </p>

</div>
</div>
<a id="ga13ddb102887ad005fb1c7406eb6d62df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13ddb102887ad005fb1c7406eb6d62df">&#9670;&nbsp;</a></span>sys_cond_timedwait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sys_cond_timedwait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__cond__t.html">sys_cond_t</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsys__mutex__t.html">sys_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait on a condition variable with timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>Pointer to the condition variable to wait on </td></tr>
    <tr><td class="paramname">mutex</td><td>Pointer to the mutex that must be locked by the calling thread </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>Timeout in milliseconds (0 = no timeout) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if signaled, false if timeout or error</dd></dl>
<p>Like <a class="el" href="group__System.html#gad6b426975c75bfd913e4ed517314a036" title="Wait on a condition variable. ">sys_cond_wait()</a> but returns after timeout_ms milliseconds if not signaled. Returns true if signaled, false if timeout or error occurred. </p>

</div>
</div>
<a id="gad6b426975c75bfd913e4ed517314a036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6b426975c75bfd913e4ed517314a036">&#9670;&nbsp;</a></span>sys_cond_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sys_cond_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__cond__t.html">sys_cond_t</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsys__mutex__t.html">sys_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mutex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait on a condition variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>Pointer to the condition variable to wait on </td></tr>
    <tr><td class="paramname">mutex</td><td>Pointer to the mutex that must be locked by the calling thread </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the wait completed successfully, false on error</dd></dl>
<p>Atomically releases the mutex and waits for the condition variable to be signaled. Upon return, the mutex is reacquired. The mutex must be locked by the calling thread before calling this function. </p>

</div>
</div>
<a id="gad8c695090d16fb853c6289a21c2db91b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8c695090d16fb853c6289a21c2db91b">&#9670;&nbsp;</a></span>sys_event_queue_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sys_event_queue_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__event__queue__t.html">sys_event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the queue is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Pointer to the event queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if empty, false otherwise</dd></dl>
<p>Returns true if the queue contains no events. This is a snapshot value that may change immediately after the call returns in a multi-threaded environment. </p>

</div>
</div>
<a id="gab4f27a3c63a3d274f23d4111dc05315a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4f27a3c63a3d274f23d4111dc05315a">&#9670;&nbsp;</a></span>sys_event_queue_finalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_event_queue_finalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__event__queue__t.html">sys_event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize and cleanup an event queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Pointer to the queue to finalize</td></tr>
  </table>
  </dd>
</dl>
<p>Finalizes the event queue and releases all associated resources. Any threads waiting on the queue will be woken up. The queue should not be used after this call. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="pico_2simplequeue_2main_8c-example.html#a14">pico/simplequeue/main.c</a>.</dd>
</dl>
</div>
</div>
<a id="gadf5a5676c999a3f4e21608a21e7e636f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf5a5676c999a3f4e21608a21e7e636f">&#9670;&nbsp;</a></span>sys_event_queue_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsys__event__queue__t.html">sys_event_queue_t</a> sys_event_queue_init </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a new event queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>Maximum number of events the queue can hold </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Initialized event queue structure</dd></dl>
<p>Creates a new thread-safe event queue with the specified capacity. The queue uses circular buffer semantics - when full, new items will overwrite the oldest items. The returned queue must be finalized with <a class="el" href="group__System.html#gab4f27a3c63a3d274f23d4111dc05315a" title="Finalize and cleanup an event queue. ">sys_event_queue_finalize()</a>. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="pico_2runloop_2main_8c-example.html#a18">pico/runloop/main.c</a>, and <a class="el" href="pico_2simplequeue_2main_8c-example.html#a10">pico/simplequeue/main.c</a>.</dd>
</dl>
</div>
</div>
<a id="ga2e1bf7986654d89f6debd775158dc685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e1bf7986654d89f6debd775158dc685">&#9670;&nbsp;</a></span>sys_event_queue_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sys_event_queue_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__event__queue__t.html">sys_event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock the queue for manual synchronization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Pointer to the event queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false on error</dd></dl>
<p>Manually locks the queue mutex. This allows for atomic sequences of peek/pop operations. Must be paired with <a class="el" href="group__System.html#gaebe7204ad57c101cbbb0eb1ccef42168" title="Unlock the queue after manual synchronization. ">sys_event_queue_unlock()</a>. </p>

</div>
</div>
<a id="ga4fd435e560a0892a61851b0f66c56f9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fd435e560a0892a61851b0f66c56f9a">&#9670;&nbsp;</a></span>sys_event_queue_peek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__System.html#ga2bdd4be7e6e04b4ee95e0459ff001702">sys_event_t</a> sys_event_queue_peek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__event__queue__t.html">sys_event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Peek at the next event without removing it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Pointer to the event queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next event or NULL if queue is empty</dd></dl>
<p>Returns the next event that would be returned by <a class="el" href="group__System.html#gadce3a0a7f3b32706c7064e8659d52b21" title="Remove and return the next event (blocking) ">sys_event_queue_pop()</a> without removing it from the queue. This allows consumers to inspect events before deciding whether to acquire them. The queue must be locked by the caller. </p>

</div>
</div>
<a id="gadce3a0a7f3b32706c7064e8659d52b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadce3a0a7f3b32706c7064e8659d52b21">&#9670;&nbsp;</a></span>sys_event_queue_pop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__System.html#ga2bdd4be7e6e04b4ee95e0459ff001702">sys_event_t</a> sys_event_queue_pop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__event__queue__t.html">sys_event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove and return the next event (blocking) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Pointer to the event queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next event, or NULL if queue is shut down</dd></dl>
<p>Removes and returns the next event from the queue. If the queue is empty, this function blocks until an event becomes available or the queue is shut down. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="pico_2runloop_2main_8c-example.html#a3">pico/runloop/main.c</a>, and <a class="el" href="pico_2simplequeue_2main_8c-example.html#a12">pico/simplequeue/main.c</a>.</dd>
</dl>
</div>
</div>
<a id="gaf3b1d50d0e78404ebd74355a474fb10b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3b1d50d0e78404ebd74355a474fb10b">&#9670;&nbsp;</a></span>sys_event_queue_push()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sys_event_queue_push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__event__queue__t.html">sys_event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__System.html#ga2bdd4be7e6e04b4ee95e0459ff001702">sys_event_t</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push an event to the queue (always succeeds) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Pointer to the event queue </td></tr>
    <tr><td class="paramname">event</td><td>Event to add to the queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false on error</dd></dl>
<p>Adds an event to the queue. This operation always succeeds - if the queue is full, the oldest event is overwritten. This ensures producers are never blocked. </p>

</div>
</div>
<a id="gac94e5bdf92c1b596445730c992e27c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac94e5bdf92c1b596445730c992e27c60">&#9670;&nbsp;</a></span>sys_event_queue_shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_event_queue_shutdown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__event__queue__t.html">sys_event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shut down the queue gracefully. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Pointer to the event queue</td></tr>
  </table>
  </dd>
</dl>
<p>Sets the shutdown flag and wakes up all waiting consumers. After shutdown, push operations may fail and pop operations will return NULL once the queue is empty. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="pico_2runloop_2main_8c-example.html#a10">pico/runloop/main.c</a>, and <a class="el" href="pico_2simplequeue_2main_8c-example.html#a9">pico/simplequeue/main.c</a>.</dd>
</dl>
</div>
</div>
<a id="ga0ca657c0597f3133a202f68c7f91f6fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ca657c0597f3133a202f68c7f91f6fd">&#9670;&nbsp;</a></span>sys_event_queue_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t sys_event_queue_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__event__queue__t.html">sys_event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current number of events in the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Pointer to the event queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current number of events, or 0 on error</dd></dl>
<p>Returns the current number of events in the queue. This is a snapshot value that may change immediately after the call returns in a multi-threaded environment. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="pico_2runloop_2main_8c-example.html#a4">pico/runloop/main.c</a>, and <a class="el" href="pico_2simplequeue_2main_8c-example.html#a13">pico/simplequeue/main.c</a>.</dd>
</dl>
</div>
</div>
<a id="gad09cd8375749826b96633ff0d138902b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad09cd8375749826b96633ff0d138902b">&#9670;&nbsp;</a></span>sys_event_queue_timed_pop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__System.html#ga2bdd4be7e6e04b4ee95e0459ff001702">sys_event_t</a> sys_event_queue_timed_pop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__event__queue__t.html">sys_event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove and return the next event with timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Pointer to the event queue </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>Timeout in milliseconds (0 = no timeout) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next event, or NULL if timeout or queue shut down</dd></dl>
<p>Removes and returns the next event from the queue. If the queue is empty, waits up to timeout_ms milliseconds for an event to become available. </p>

</div>
</div>
<a id="ga37045eb6c48834403c8fc2bbafa5e202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37045eb6c48834403c8fc2bbafa5e202">&#9670;&nbsp;</a></span>sys_event_queue_try_pop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__System.html#ga2bdd4be7e6e04b4ee95e0459ff001702">sys_event_t</a> sys_event_queue_try_pop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__event__queue__t.html">sys_event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to remove and return the next event (non-blocking) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Pointer to the event queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next event, or NULL if queue is empty or error</dd></dl>
<p>Attempts to remove and return the next event from the queue. Returns NULL immediately if the queue is empty. </p>

</div>
</div>
<a id="gac876f605be4e2014ec50a51848d2bb21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac876f605be4e2014ec50a51848d2bb21">&#9670;&nbsp;</a></span>sys_event_queue_try_push()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sys_event_queue_try_push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__event__queue__t.html">sys_event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__System.html#ga2bdd4be7e6e04b4ee95e0459ff001702">sys_event_t</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to push an event without overwriting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Pointer to the event queue </td></tr>
    <tr><td class="paramname">event</td><td>Event to add to the queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false if queue is full or error</dd></dl>
<p>Attempts to add an event to the queue. Returns false if the queue is full, ensuring no existing events are overwritten. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="pico_2runloop_2main_8c-example.html#a14">pico/runloop/main.c</a>, and <a class="el" href="pico_2simplequeue_2main_8c-example.html#a5">pico/simplequeue/main.c</a>.</dd>
</dl>
</div>
</div>
<a id="gaebe7204ad57c101cbbb0eb1ccef42168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebe7204ad57c101cbbb0eb1ccef42168">&#9670;&nbsp;</a></span>sys_event_queue_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sys_event_queue_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__event__queue__t.html">sys_event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock the queue after manual synchronization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Pointer to the event queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false on error</dd></dl>
<p>Unlocks the queue mutex. Must be called after <a class="el" href="group__System.html#ga2e1bf7986654d89f6debd775158dc685" title="Lock the queue for manual synchronization. ">sys_event_queue_lock()</a>. </p>

</div>
</div>
<a id="ga0b1ddbaf824f0a7fb7292c26883fd061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b1ddbaf824f0a7fb7292c26883fd061">&#9670;&nbsp;</a></span>sys_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a block of memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to the memory block to be deallocated. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="pico_2runloop_2main_8c-example.html#a7">pico/runloop/main.c</a>, and <a class="el" href="pico_2simplequeue_2main_8c-example.html#a6">pico/simplequeue/main.c</a>.</dd>
</dl>
</div>
</div>
<a id="ga991bebea4457d3b1ee1fecc326e8186c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga991bebea4457d3b1ee1fecc326e8186c">&#9670;&nbsp;</a></span>sys_hash_finalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t* sys_hash_finalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__hash__t.html">sys_hash_t</a> *&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalizes the hash computation and returns the hash value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The hash context to finalize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the computed hash value, or NULL on failure.</dd></dl>
<p>This function finalizes the hash computation and returns a pointer to the computed hash value stored in the <a class="el" href="structsys__hash__t.html" title="Hash context structure. ">sys_hash_t</a> instance. The context is automatically cleaned up after finalization. </p>

</div>
</div>
<a id="ga11ae4ec7ba4ce8204080783ec4820165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11ae4ec7ba4ce8204080783ec4820165">&#9670;&nbsp;</a></span>sys_hash_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsys__hash__t.html">sys_hash_t</a> sys_hash_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__System.html#ga3d01ed00e5a4f0a1c2ea0bbf5233e899">sys_hash_algorithm_t</a>&#160;</td>
          <td class="paramname"><em>algorithm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new hash context for the specified algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">algorithm</td><td>The hash algorithm to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="structsys__hash__t.html" title="Hash context structure. ">sys_hash_t</a> instance initialized for the specified algorithm.</dd></dl>
<p>This function returns a <a class="el" href="structsys__hash__t.html" title="Hash context structure. ">sys_hash_t</a> instance for the specified hash algorithm, ready for use in hashing operations. You must call sys_hash_final() to finalize the hash computation, even on failure of <a class="el" href="group__System.html#ga64b3413178b06e7e85604dd32f27d1a5" title="Updates the hash context with new data. ">sys_hash_update()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>If a specific algorithm is not supported, the context will be initialized with size 0. You should check <a class="el" href="group__System.html#gad03b5376d31a464be04db43aa371413b" title="Returns the size of the hash in bytes. ">sys_hash_size()</a> to verify if the context is usable. </dd></dl>

</div>
</div>
<a id="gad03b5376d31a464be04db43aa371413b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad03b5376d31a464be04db43aa371413b">&#9670;&nbsp;</a></span>sys_hash_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t sys_hash_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__hash__t.html">sys_hash_t</a> *&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the hash in bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The hash context to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the hash in bytes.</dd></dl>
<p>This function returns the size of the hash value stored in the <a class="el" href="structsys__hash__t.html" title="Hash context structure. ">sys_hash_t</a> instance, which is determined by the algorithm used. If the hashing failed, the size will be 0. </p>

</div>
</div>
<a id="ga64b3413178b06e7e85604dd32f27d1a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64b3413178b06e7e85604dd32f27d1a5">&#9670;&nbsp;</a></span>sys_hash_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sys_hash_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__hash__t.html">sys_hash_t</a> *&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the hash context with new data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The hash context to update. </td></tr>
    <tr><td class="paramname">data</td><td>The data to add to the hash. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the data in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a id="ga6120ff4195b27fbb71b2fa7e5ddb29c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6120ff4195b27fbb71b2fa7e5ddb29c3">&#9670;&nbsp;</a></span>sys_malloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sys_malloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a block of memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The number of bytes to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the allocated memory, or NULL if the allocation fails. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="pico_2runloop_2main_8c-example.html#a12">pico/runloop/main.c</a>, and <a class="el" href="pico_2simplequeue_2main_8c-example.html#a3">pico/simplequeue/main.c</a>.</dd>
</dl>
</div>
</div>
<a id="ga77f042ac51dec1bb8b23525569b3f777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77f042ac51dec1bb8b23525569b3f777">&#9670;&nbsp;</a></span>sys_memcmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sys_memcmp </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two memory blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr1</td><td>First memory block </td></tr>
    <tr><td class="paramname">ptr2</td><td>Second memory block </td></tr>
    <tr><td class="paramname">num</td><td>Number of bytes to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if equal, negative if ptr1 &lt; ptr2, positive if ptr1 &gt; ptr2 </dd></dl>

</div>
</div>
<a id="ga3eb9d4345a9504a321b577c12fd115fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3eb9d4345a9504a321b577c12fd115fa">&#9670;&nbsp;</a></span>sys_memcpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sys_memcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy memory from source to destination. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Destination memory block </td></tr>
    <tr><td class="paramname">src</td><td>Source memory block </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to destination, or NULL on error </dd></dl>

</div>
</div>
<a id="ga5072718fc98e368bb925c0f746a1ae6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5072718fc98e368bb925c0f746a1ae6b">&#9670;&nbsp;</a></span>sys_memmove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sys_memmove </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move memory from source to destination (handles overlapping regions) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Destination memory block </td></tr>
    <tr><td class="paramname">src</td><td>Source memory block </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to move </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to destination, or NULL on error </dd></dl>

</div>
</div>
<a id="gaf09714d849584f8d9866562a2b65c06e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf09714d849584f8d9866562a2b65c06e">&#9670;&nbsp;</a></span>sys_memset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sys_memset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set memory to a specific value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the memory block </td></tr>
    <tr><td class="paramname">value</td><td>Value to set each byte to </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the memory block, or NULL on error </dd></dl>

</div>
</div>
<a id="gaaeb0d92904b70d289a5f4a6a5f93c76a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaeb0d92904b70d289a5f4a6a5f93c76a">&#9670;&nbsp;</a></span>sys_mutex_finalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_mutex_finalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__mutex__t.html">sys_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize and cleanup a mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>Pointer to the mutex to finalize</td></tr>
  </table>
  </dd>
</dl>
<p>Releases all resources associated with the mutex and renders it unusable. The mutex should not be locked when this function is called. </p>

</div>
</div>
<a id="ga57eff626a70b50a6dd10fb2893a1dc2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57eff626a70b50a6dd10fb2893a1dc2e">&#9670;&nbsp;</a></span>sys_mutex_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsys__mutex__t.html">sys_mutex_t</a> sys_mutex_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a new mutex. </p>
<dl class="section return"><dt>Returns</dt><dd>Initialized mutex structure</dd></dl>
<p>Creates and initializes a new mutex for thread synchronization. The mutex is initially unlocked and ready for use. The returned mutex must be finalized with <a class="el" href="group__System.html#gaaeb0d92904b70d289a5f4a6a5f93c76a" title="Finalize and cleanup a mutex. ">sys_mutex_finalize()</a> </p>

</div>
</div>
<a id="ga138955bcde069851868561cd20fb876a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga138955bcde069851868561cd20fb876a">&#9670;&nbsp;</a></span>sys_mutex_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sys_mutex_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__mutex__t.html">sys_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock a mutex, by blocking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>Pointer to the mutex to lock </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the mutex was successfully locked, false on error</dd></dl>
<p>Attempts to lock the specified mutex. If the mutex is already locked by another thread, this function will block until the mutex becomes available. Every successful lock must be paired with <a class="el" href="group__System.html#ga7c24c3cfd80c2e2b8963aec0b895fe3d" title="Unlock a mutex. ">sys_mutex_unlock()</a> Attempting to lock an already owned mutex may result in deadlock </p>

</div>
</div>
<a id="gaec452afb418073c5212e6f9abdcedfe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec452afb418073c5212e6f9abdcedfe1">&#9670;&nbsp;</a></span>sys_mutex_trylock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sys_mutex_trylock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__mutex__t.html">sys_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to lock a mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>Pointer to the mutex to try locking </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the mutex was successfully locked, false if already locked or on error</dd></dl>
<p>Attempts to lock the specified mutex without blocking. If the mutex is already locked, this function returns immediately with false. Every successful trylock must be paired with <a class="el" href="group__System.html#ga7c24c3cfd80c2e2b8963aec0b895fe3d" title="Unlock a mutex. ">sys_mutex_unlock()</a> </p>

</div>
</div>
<a id="ga7c24c3cfd80c2e2b8963aec0b895fe3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c24c3cfd80c2e2b8963aec0b895fe3d">&#9670;&nbsp;</a></span>sys_mutex_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sys_mutex_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__mutex__t.html">sys_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock a mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>Pointer to the mutex to unlock </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the mutex was successfully unlocked, false on error</dd></dl>
<p>Releases a previously acquired mutex lock, allowing other threads to acquire the mutex. Only the thread that locked the mutex should unlock it. </p>

</div>
</div>
<a id="ga795b667df1ea24eeb5045a9f625f8611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga795b667df1ea24eeb5045a9f625f8611">&#9670;&nbsp;</a></span>sys_panicf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_panicf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a formatted panic message and aborts the process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fmt</td><td>A printf-style format string specifying the panic message. </td></tr>
    <tr><td class="paramname">...</td><td>Additional arguments corresponding to format specifiers in fmt. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not return to the caller. </dd></dl>

</div>
</div>
<a id="gab6bda746d6b03c697ebcf468f83fdb6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6bda746d6b03c697ebcf468f83fdb6d">&#9670;&nbsp;</a></span>sys_printf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t sys_printf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints formatted output to the system console. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>A printf-style format string that specifies how subsequent arguments are formatted and printed. </td></tr>
    <tr><td class="paramname">...</td><td>Additional arguments corresponding to format specifiers in format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters printed. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="pico_2multicore_2main_8c-example.html#a1">pico/multicore/main.c</a>, <a class="el" href="pico_2runloop_2main_8c-example.html#a2">pico/runloop/main.c</a>, and <a class="el" href="pico_2simplequeue_2main_8c-example.html#a1">pico/simplequeue/main.c</a>.</dd>
</dl>
</div>
</div>
<a id="gae13dd8a6d75ee7e807c43ae84ec66dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae13dd8a6d75ee7e807c43ae84ec66dfd">&#9670;&nbsp;</a></span>sys_putch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_putch </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs a character to the system console or standard output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to be output.</td></tr>
  </table>
  </dd>
</dl>
<p>This function writes the specified character to the system's standard output stream, but does not flush the output buffer. </p>

</div>
</div>
<a id="ga4eced11c2352451c4ea6c7386e58342b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4eced11c2352451c4ea6c7386e58342b">&#9670;&nbsp;</a></span>sys_puts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_puts </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs a string to the system console or standard output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>A pointer to a null-terminated string to be output. If <code>str</code> is <code>NULL</code>, existing output is flushed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function writes the specified null-terminated string to the system's standard output stream, and flushes the output buffer. </p>

</div>
</div>
<a id="ga39c02847b060cfe7b9c568a06bc7ad74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39c02847b060cfe7b9c568a06bc7ad74">&#9670;&nbsp;</a></span>sys_random_uint32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sys_random_uint32 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a random number as a 32-bit unsigned integer. </p>
<dl class="section return"><dt>Returns</dt><dd>A random unsigned 32-bit integer value. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The function may not be thread-safe depending on the platform implementation. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="pico_2multicore_2main_8c-example.html#a4">pico/multicore/main.c</a>, <a class="el" href="pico_2runloop_2main_8c-example.html#a6">pico/runloop/main.c</a>, and <a class="el" href="pico_2simplequeue_2main_8c-example.html#a8">pico/simplequeue/main.c</a>.</dd>
</dl>
</div>
</div>
<a id="ga2fce61e0b72cfddf664a85be328cddab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fce61e0b72cfddf664a85be328cddab">&#9670;&nbsp;</a></span>sys_random_uint64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t sys_random_uint64 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a random number as a 64-bit unsigned integer. </p>
<dl class="section return"><dt>Returns</dt><dd>A random unsigned 64-bit integer value. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The function may not be thread-safe depending on the platform implementation. </dd></dl>

</div>
</div>
<a id="gacb5a950a99bad2a938dee8c861e50269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb5a950a99bad2a938dee8c861e50269">&#9670;&nbsp;</a></span>sys_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_sleep </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>msec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pauses the execution of the current thread for a specified time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msec</td><td>The number of milliseconds to sleep. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="pico_2multicore_2main_8c-example.html#a3">pico/multicore/main.c</a>, <a class="el" href="pico_2runloop_2main_8c-example.html#a5">pico/runloop/main.c</a>, and <a class="el" href="pico_2simplequeue_2main_8c-example.html#a7">pico/simplequeue/main.c</a>.</dd>
</dl>
</div>
</div>
<a id="ga340ab3d1b3e0cef587d52b580cd59d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga340ab3d1b3e0cef587d52b580cd59d25">&#9670;&nbsp;</a></span>sys_sprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t sys_sprintf </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints formatted output to a string buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the destination buffer where the formatted string will be stored. If NULL, only the length is calculated. </td></tr>
    <tr><td class="paramname">sz</td><td>Size of the destination buffer in bytes, including space for the null terminator. </td></tr>
    <tr><td class="paramname">format</td><td>A printf-style format string. </td></tr>
    <tr><td class="paramname">...</td><td>Additional arguments corresponding to format specifiers in format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters that would have been written if the buffer was sufficiently large, not counting the null terminator. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="pico_2runloop_2main_8c-example.html#a13">pico/runloop/main.c</a>, and <a class="el" href="pico_2simplequeue_2main_8c-example.html#a4">pico/simplequeue/main.c</a>.</dd>
</dl>
</div>
</div>
<a id="ga4c6d6105e812d597fd8457f1d79290cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c6d6105e812d597fd8457f1d79290cc">&#9670;&nbsp;</a></span>sys_thread_core()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t sys_thread_core </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the CPU core number the current thread is running on. </p>
<dl class="section return"><dt>Returns</dt><dd>The core number (0-based) that the current thread is executing on. Returns 0 if the core cannot be determined or on single-core systems.</dd></dl>
<p>This function queries the system to determine which CPU core the calling thread is currently scheduled on. Note that threads may migrate between cores, so this value may change over time unless thread affinity is set. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="pico_2multicore_2main_8c-example.html#a2">pico/multicore/main.c</a>, <a class="el" href="pico_2runloop_2main_8c-example.html#a1">pico/runloop/main.c</a>, and <a class="el" href="pico_2simplequeue_2main_8c-example.html#a2">pico/simplequeue/main.c</a>.</dd>
</dl>
</div>
</div>
<a id="ga677402551d5d11b4e3ee60391d5a4faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga677402551d5d11b4e3ee60391d5a4faf">&#9670;&nbsp;</a></span>sys_thread_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sys_thread_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__System.html#ga44d92420e9c1148c746ce7e89a81075d">sys_thread_func_t</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a thread on any available core. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function to execute in the new thread </td></tr>
    <tr><td class="paramname">arg</td><td>Argument to pass to the thread function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if thread was created successfully, false if no cores available or error</dd></dl>
<p>Creates a new thread that executes the specified function with the given argument. The thread runs independently and terminates when the function returns. No cleanup or joining is required - the thread is fire-and-forget. On systems with multiple cores, the thread may be scheduled on any available core. </p>

</div>
</div>
<a id="ga1b72ef6424828a90881daa3559864cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b72ef6424828a90881daa3559864cf4">&#9670;&nbsp;</a></span>sys_thread_create_on_core()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sys_thread_create_on_core </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__System.html#ga44d92420e9c1148c746ce7e89a81075d">sys_thread_func_t</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>core</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a thread on a specific core. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function to execute in the new thread </td></tr>
    <tr><td class="paramname">arg</td><td>Argument to pass to the thread function </td></tr>
    <tr><td class="paramname">core</td><td>Core number to run the thread on (0-based) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if thread was created on the specified core, false if core unavailable or error</dd></dl>
<p>Creates a new thread that executes the specified function on a specific CPU core. The thread runs independently and terminates when the function returns. If the specified core is not available or already in use, the function returns false. Core 0 is typically the main/boot core. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="pico_2multicore_2main_8c-example.html#a8">pico/multicore/main.c</a>, <a class="el" href="pico_2runloop_2main_8c-example.html#a19">pico/runloop/main.c</a>, and <a class="el" href="pico_2simplequeue_2main_8c-example.html#a11">pico/simplequeue/main.c</a>.</dd>
</dl>
</div>
</div>
<a id="gafd9cf2d40386c9cef130e39d39155293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd9cf2d40386c9cef130e39d39155293">&#9670;&nbsp;</a></span>sys_thread_numcores()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t sys_thread_numcores </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of CPU cores available on the host system. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of CPU cores available on the system. Returns 1 if the number of cores cannot be determined or if the system has only one core.</dd></dl>
<p>This function queries the system to determine the total number of processing cores available. </p>

</div>
</div>
<a id="ga4ca6ec26efbd88031d42509a07482f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ca6ec26efbd88031d42509a07482f3d">&#9670;&nbsp;</a></span>sys_time_compare_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t sys_time_compare_ns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__System.html#ga45596b2dc3b59917dfbbf36d5b3d4816">sys_time_t</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__System.html#ga45596b2dc3b59917dfbbf36d5b3d4816">sys_time_t</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the difference in nanoseconds between two sys_time_t structures. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Pointer to the start time. If <code>NULL</code>, this is treated as the epoch (seconds since January 1, 1970). </td></tr>
    <tr><td class="paramname">end</td><td>Pointer to the end time. If <code>NULL</code>, this is treated as the current time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference in nanoseconds. If end is earlier than start, returns a negative value. </dd></dl>

</div>
</div>
<a id="ga34afa8ff2a90627f3119d0fe662fdb89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34afa8ff2a90627f3119d0fe662fdb89">&#9670;&nbsp;</a></span>sys_time_get_date_utc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sys_time_get_date_utc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__System.html#ga45596b2dc3b59917dfbbf36d5b3d4816">sys_time_t</a> *&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>year</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>month</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>day</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>weekday</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts date components from a sys_time_t structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>Pointer to a sys_time_t structure to extract date from. </td></tr>
    <tr><td class="paramname">year</td><td>Pointer to store year (e.g., 2025), or NULL to skip. </td></tr>
    <tr><td class="paramname">month</td><td>Pointer to store month (1-12), or NULL to skip. </td></tr>
    <tr><td class="paramname">day</td><td>Pointer to store day (1-31), or NULL to skip. </td></tr>
    <tr><td class="paramname">weekday</td><td>Pointer to store weekday (0-6, where 0=Sunday), or NULL to skip. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on error. </dd></dl>

</div>
</div>
<a id="ga664e2499cff45dfad7da8a16ad873dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga664e2499cff45dfad7da8a16ad873dfd">&#9670;&nbsp;</a></span>sys_time_get_time_utc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sys_time_get_time_utc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__System.html#ga45596b2dc3b59917dfbbf36d5b3d4816">sys_time_t</a> *&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>hours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>minutes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>seconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts time components from a sys_time_t structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>Pointer to a sys_time_t structure to extract time from. </td></tr>
    <tr><td class="paramname">hours</td><td>Pointer to store hours (0-23), or NULL to skip. </td></tr>
    <tr><td class="paramname">minutes</td><td>Pointer to store minutes (0-59), or NULL to skip. </td></tr>
    <tr><td class="paramname">seconds</td><td>Pointer to store seconds (0-59), or NULL to skip. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on error. </dd></dl>

</div>
</div>
<a id="ga0f593b86e80e479fff851b0b0c715da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f593b86e80e479fff851b0b0c715da0">&#9670;&nbsp;</a></span>sys_time_get_utc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sys_time_get_utc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__System.html#ga45596b2dc3b59917dfbbf36d5b3d4816">sys_time_t</a> *&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current UTC time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>Pointer to a sys_time_t structure to fill with current time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on error. </dd></dl>

</div>
</div>
<a id="gaad6616ff63c8cbdbaf3fd97697bb074c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad6616ff63c8cbdbaf3fd97697bb074c">&#9670;&nbsp;</a></span>sys_time_set_date_utc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sys_time_set_date_utc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__System.html#ga45596b2dc3b59917dfbbf36d5b3d4816">sys_time_t</a> *&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>year</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>month</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>day</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets date components in a sys_time_t structure, preserving the time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>Pointer to a sys_time_t structure to modify. </td></tr>
    <tr><td class="paramname">year</td><td>Year to set (supports pre-epoch dates, e.g., 1969, 1900). </td></tr>
    <tr><td class="paramname">month</td><td>Month to set (1-12). </td></tr>
    <tr><td class="paramname">day</td><td>Day to set (1-31). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on error or invalid parameters. </dd></dl>

</div>
</div>
<a id="ga172740122067a523d9d32478126db59b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga172740122067a523d9d32478126db59b">&#9670;&nbsp;</a></span>sys_time_set_time_utc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sys_time_set_time_utc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__System.html#ga45596b2dc3b59917dfbbf36d5b3d4816">sys_time_t</a> *&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>hours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>minutes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>seconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets time components in a sys_time_t structure, preserving the date. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>Pointer to a sys_time_t structure to modify. </td></tr>
    <tr><td class="paramname">hours</td><td>Hours to set (0-23). </td></tr>
    <tr><td class="paramname">minutes</td><td>Minutes to set (0-59). </td></tr>
    <tr><td class="paramname">seconds</td><td>Seconds to set (0-59). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on error or invalid parameters. </dd></dl>

</div>
</div>
<a id="ga03c3073fd8f641e7cea076652bbe11dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03c3073fd8f641e7cea076652bbe11dd">&#9670;&nbsp;</a></span>sys_timer_finalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sys_timer_finalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__timer__t.html">sys_timer_t</a> *&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancels and finalizes a timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>The timer context to finalize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. This function stops the timer and cleans up any resources associated with it. After calling this function, the timer context becomes invalid and should not be used again. To use a timer with the same configuration, initialize a new timer using <a class="el" href="group__System.html#gac1368a749ee9713f5339cfc2b27dbdcd" title="Initializes a new timer context. ">sys_timer_init()</a>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="pico_2runloop_2main_8c-example.html#a11">pico/runloop/main.c</a>.</dd>
</dl>
</div>
</div>
<a id="gac1368a749ee9713f5339cfc2b27dbdcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1368a749ee9713f5339cfc2b27dbdcd">&#9670;&nbsp;</a></span>sys_timer_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsys__timer__t.html">sys_timer_t</a> sys_timer_init </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interval_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="structsys__timer__t.html">sys_timer_t</a> *)&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new timer context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interval_ms</td><td>The periodic interval for the timer in milliseconds. </td></tr>
    <tr><td class="paramname">userdata</td><td>Optional user data to pass to the callback. </td></tr>
    <tr><td class="paramname">callback</td><td>The function to call on each timer event. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="structsys__timer__t.html" title="Timer context structure. ">sys_timer_t</a> instance initialized with the specified parameters.</dd></dl>
<p>This function returns a <a class="el" href="structsys__timer__t.html" title="Timer context structure. ">sys_timer_t</a> instance for the specified timer configuration, ready for use in starting and stopping the timer. Use <a class="el" href="group__System.html#ga0aeeb7a38cc0c6e93ff30bf1ed6f4772" title="Starts a timer. ">sys_timer_start()</a> to start the timer and <a class="el" href="group__System.html#ga03c3073fd8f641e7cea076652bbe11dd" title="Cancels and finalizes a timer. ">sys_timer_finalize()</a> to stop and clean up the timer. If you want to define a one-shot timer, call <a class="el" href="group__System.html#ga03c3073fd8f641e7cea076652bbe11dd" title="Cancels and finalizes a timer. ">sys_timer_finalize()</a> in your callback function. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="pico_2runloop_2main_8c-example.html#a15">pico/runloop/main.c</a>.</dd>
</dl>
</div>
</div>
<a id="ga0aeeb7a38cc0c6e93ff30bf1ed6f4772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0aeeb7a38cc0c6e93ff30bf1ed6f4772">&#9670;&nbsp;</a></span>sys_timer_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sys_timer_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__timer__t.html">sys_timer_t</a> *&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>The timer context to start. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure.</dd></dl>
<p>This function starts the timer with the specified interval and callback. If the timer is invalid, or cannot be started, the function returns false. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="pico_2runloop_2main_8c-example.html#a16">pico/runloop/main.c</a>.</dd>
</dl>
</div>
</div>
<a id="gaac71469c45207a063e75bf7e6c2dbb5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac71469c45207a063e75bf7e6c2dbb5b">&#9670;&nbsp;</a></span>sys_vprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t sys_vprintf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints formatted output using a va_list argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>A printf-style format string. </td></tr>
    <tr><td class="paramname">args</td><td>A va_list containing the arguments for the format string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters printed. </dd></dl>

</div>
</div>
<a id="ga86745087b8aeeae5c0715896240ab992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86745087b8aeeae5c0715896240ab992">&#9670;&nbsp;</a></span>sys_vsprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t sys_vsprintf </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints formatted output to a string buffer using a va_list argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the destination buffer where the formatted string will be stored. If NULL, only the length is calculated. </td></tr>
    <tr><td class="paramname">sz</td><td>Size of the destination buffer in bytes, including space for the null terminator. </td></tr>
    <tr><td class="paramname">format</td><td>A printf-style format string. </td></tr>
    <tr><td class="paramname">args</td><td>A va_list containing the arguments for the format string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters that would have been written if the buffer was sufficiently large, not counting the null terminator. </dd></dl>

</div>
</div>
<a id="ga6fe6dc303b2686856f6496f8c3589eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fe6dc303b2686856f6496f8c3589eeb">&#9670;&nbsp;</a></span>sys_waitgroup_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sys_waitgroup_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__waitgroup__t.html">sys_waitgroup_t</a> *&#160;</td>
          <td class="paramname"><em>wg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to the waitgroup counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wg</td><td>Pointer to the waitgroup </td></tr>
    <tr><td class="paramname">delta</td><td>Number to add to the counter (must be positive) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false on error</dd></dl>
<p>Increments the waitgroup counter by delta. This should be called before starting goroutines that the waitgroup should wait for. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="pico_2multicore_2main_8c-example.html#a7">pico/multicore/main.c</a>.</dd>
</dl>
</div>
</div>
<a id="ga6bc3531da1d947e8b588749cecc2b692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bc3531da1d947e8b588749cecc2b692">&#9670;&nbsp;</a></span>sys_waitgroup_done()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sys_waitgroup_done </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__waitgroup__t.html">sys_waitgroup_t</a> *&#160;</td>
          <td class="paramname"><em>wg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrement the waitgroup counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wg</td><td>Pointer to the waitgroup </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false on error</dd></dl>
<p>Decrements the waitgroup counter by 1. This should be called when a goroutine finishes its work. If the counter reaches 0, all threads waiting on sys_waitgroup_wait() will be woken up. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="pico_2multicore_2main_8c-example.html#a5">pico/multicore/main.c</a>.</dd>
</dl>
</div>
</div>
<a id="gabca9a01a0834ad14251f39c45a1120d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabca9a01a0834ad14251f39c45a1120d6">&#9670;&nbsp;</a></span>sys_waitgroup_finalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_waitgroup_finalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsys__waitgroup__t.html">sys_waitgroup_t</a> *&#160;</td>
          <td class="paramname"><em>wg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize and cleanup a waitgroup - wait for completion then cleanup. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wg</td><td>Pointer to the waitgroup to finalize</td></tr>
  </table>
  </dd>
</dl>
<p>Blocks until the waitgroup counter reaches 0, then releases all resources associated with the waitgroup and renders it unusable. The waitgroup counter should reach 0 through done() calls from worker threads. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="pico_2multicore_2main_8c-example.html#a9">pico/multicore/main.c</a>.</dd>
</dl>
</div>
</div>
<a id="ga054b7429932a28dd301dacca5adb97e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga054b7429932a28dd301dacca5adb97e5">&#9670;&nbsp;</a></span>sys_waitgroup_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsys__waitgroup__t.html">sys_waitgroup_t</a> sys_waitgroup_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a new waitgroup. </p>
<dl class="section return"><dt>Returns</dt><dd>Initialized waitgroup structure</dd></dl>
<p>Creates and initializes a new waitgroup for thread synchronization. The waitgroup counter starts at 0. The returned waitgroup must be finalized with <a class="el" href="group__System.html#gabca9a01a0834ad14251f39c45a1120d6" title="Finalize and cleanup a waitgroup - wait for completion then cleanup. ">sys_waitgroup_finalize()</a> </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="pico_2multicore_2main_8c-example.html#a6">pico/multicore/main.c</a>.</dd>
</dl>
</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
  </ul>
</div>
</body>
</html>
