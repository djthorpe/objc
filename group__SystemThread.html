<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>objc: Threading</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="custom.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea"><h1>objc</h1></div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Threading<div class="ingroups"><a class="el" href="group__System.html">System Runtime</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Managing threads and program execution.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Threading:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__SystemThread.png" border="0" alt="" usemap="#group____SystemThread"/>
<map name="group____SystemThread" id="group____SystemThread">
<area shape="rect" id="node2" href="group__System.html" title="The &quot;system runtime&quot; layer provides low&#45;level functionality specific to the platform. " alt="" coords="5,5,135,32"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga44d92420e9c1148c746ce7e89a81075d"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SystemThread.html#ga44d92420e9c1148c746ce7e89a81075d">sys_thread_func_t</a>) (void *arg)</td></tr>
<tr class="memdesc:ga44d92420e9c1148c746ce7e89a81075d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread function signatureFunction signature for thread entry points.  <a href="#ga44d92420e9c1148c746ce7e89a81075d">More...</a><br /></td></tr>
<tr class="separator:ga44d92420e9c1148c746ce7e89a81075d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga51400f71e4702fdbd13394546f4182bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SystemThread.html#ga51400f71e4702fdbd13394546f4182bb">sys_abort</a> (void)</td></tr>
<tr class="memdesc:ga51400f71e4702fdbd13394546f4182bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts the current process immediately.  <a href="#ga51400f71e4702fdbd13394546f4182bb">More...</a><br /></td></tr>
<tr class="separator:ga51400f71e4702fdbd13394546f4182bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga795b667df1ea24eeb5045a9f625f8611"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SystemThread.html#ga795b667df1ea24eeb5045a9f625f8611">sys_panicf</a> (const char *fmt,...)</td></tr>
<tr class="memdesc:ga795b667df1ea24eeb5045a9f625f8611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a formatted panic message and aborts the process.  <a href="#ga795b667df1ea24eeb5045a9f625f8611">More...</a><br /></td></tr>
<tr class="separator:ga795b667df1ea24eeb5045a9f625f8611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd9cf2d40386c9cef130e39d39155293"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SystemThread.html#gafd9cf2d40386c9cef130e39d39155293">sys_thread_numcores</a> (void)</td></tr>
<tr class="memdesc:gafd9cf2d40386c9cef130e39d39155293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of CPU cores available on the host system.  <a href="#gafd9cf2d40386c9cef130e39d39155293">More...</a><br /></td></tr>
<tr class="separator:gafd9cf2d40386c9cef130e39d39155293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga677402551d5d11b4e3ee60391d5a4faf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SystemThread.html#ga677402551d5d11b4e3ee60391d5a4faf">sys_thread_create</a> (<a class="el" href="group__SystemThread.html#ga44d92420e9c1148c746ce7e89a81075d">sys_thread_func_t</a> func, void *arg)</td></tr>
<tr class="memdesc:ga677402551d5d11b4e3ee60391d5a4faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a thread on any available core.  <a href="#ga677402551d5d11b4e3ee60391d5a4faf">More...</a><br /></td></tr>
<tr class="separator:ga677402551d5d11b4e3ee60391d5a4faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b72ef6424828a90881daa3559864cf4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SystemThread.html#ga1b72ef6424828a90881daa3559864cf4">sys_thread_create_on_core</a> (<a class="el" href="group__SystemThread.html#ga44d92420e9c1148c746ce7e89a81075d">sys_thread_func_t</a> func, void *arg, uint8_t core)</td></tr>
<tr class="memdesc:ga1b72ef6424828a90881daa3559864cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a thread on a specific core.  <a href="#ga1b72ef6424828a90881daa3559864cf4">More...</a><br /></td></tr>
<tr class="separator:ga1b72ef6424828a90881daa3559864cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c6d6105e812d597fd8457f1d79290cc"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SystemThread.html#ga4c6d6105e812d597fd8457f1d79290cc">sys_thread_core</a> (void)</td></tr>
<tr class="memdesc:ga4c6d6105e812d597fd8457f1d79290cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the CPU core number the current thread is running on.  <a href="#ga4c6d6105e812d597fd8457f1d79290cc">More...</a><br /></td></tr>
<tr class="separator:ga4c6d6105e812d597fd8457f1d79290cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb5a950a99bad2a938dee8c861e50269"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SystemThread.html#gacb5a950a99bad2a938dee8c861e50269">sys_sleep</a> (int32_t msec)</td></tr>
<tr class="memdesc:gacb5a950a99bad2a938dee8c861e50269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pauses the execution of the current thread for a specified time.  <a href="#gacb5a950a99bad2a938dee8c861e50269">More...</a><br /></td></tr>
<tr class="separator:gacb5a950a99bad2a938dee8c861e50269"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Managing threads and program execution. </p>
<p>This module declares types and functions for thread management, including thread creation, synchronization, and communication. It is generally aware of the number of "cores" available on the system, and allows creating threads that can run on a specific core, or on any available core.</p>
<p>However, it really depends on the platform's capabilities and requirements. as to whether you should call <a class="el" href="group__SystemThread.html#ga677402551d5d11b4e3ee60391d5a4faf" title="Create a thread on any available core. ">sys_thread_create()</a> or <a class="el" href="group__SystemThread.html#ga1b72ef6424828a90881daa3559864cf4" title="Create a thread on a specific core. ">sys_thread_create_on_core()</a>. On the Pico platform, for example, you should use <a class="el" href="group__SystemThread.html#ga1b72ef6424828a90881daa3559864cf4" title="Create a thread on a specific core. ">sys_thread_create_on_core()</a> to ensure the thread runs on a specific core. If you call this method when an existing thread is already running on that core, the core will be reset and the new thread will be scheduled to run on that core, so it's important to ensure that there isn't an existing thread already running on the specified core before calling this function.</p>
<p>The implementation of threads is like Go's goroutines, where the execution threads are "fire and forget" and do not require joining. If you wish to communicate between threads, use the event queue. If you wish to co-ordinate when threads are running or to synchronize their execution, you can use the provided synchronization primitives like waitgroups.</p>
<p>There are also methods for suspending the current thread for a specified duration, and for halting execution of the process immediately, in case of catastrophic failure. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga44d92420e9c1148c746ce7e89a81075d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44d92420e9c1148c746ce7e89a81075d">&#9670;&nbsp;</a></span>sys_thread_func_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* sys_thread_func_t) (void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread function signatureFunction signature for thread entry points. </p>
<p>The function receives a single void pointer argument and should not return a value. The thread terminates when this function returns. </p>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00054">54</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga51400f71e4702fdbd13394546f4182bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51400f71e4702fdbd13394546f4182bb">&#9670;&nbsp;</a></span>sys_abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_abort </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aborts the current process immediately. </p>
<dl class="section note"><dt>Note</dt><dd>This function does not return to the caller.</dd></dl>
<p>This function terminates the current process abnormally and immediately. It does not perform any cleanup operations and does not call exit handlers or destructors. </p>

</div>
</div>
<a id="ga795b667df1ea24eeb5045a9f625f8611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga795b667df1ea24eeb5045a9f625f8611">&#9670;&nbsp;</a></span>sys_panicf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_panicf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a formatted panic message and aborts the process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fmt</td><td>A printf-style format string specifying the panic message. </td></tr>
    <tr><td class="paramname">...</td><td>Additional arguments corresponding to format specifiers in fmt. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not return to the caller. </dd></dl>

</div>
</div>
<a id="gacb5a950a99bad2a938dee8c861e50269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb5a950a99bad2a938dee8c861e50269">&#9670;&nbsp;</a></span>sys_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_sleep </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>msec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pauses the execution of the current thread for a specified time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msec</td><td>The number of milliseconds to sleep. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="pico_2multicore_2main_8c-example.html#a3">pico/multicore/main.c</a>, <a class="el" href="pico_2runloop_2main_8c-example.html#a5">pico/runloop/main.c</a>, and <a class="el" href="pico_2simplequeue_2main_8c-example.html#a7">pico/simplequeue/main.c</a>.</dd>
</dl>
</div>
</div>
<a id="ga4c6d6105e812d597fd8457f1d79290cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c6d6105e812d597fd8457f1d79290cc">&#9670;&nbsp;</a></span>sys_thread_core()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t sys_thread_core </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the CPU core number the current thread is running on. </p>
<dl class="section return"><dt>Returns</dt><dd>The core number (0-based) that the current thread is executing on. Returns 0 if the core cannot be determined or on single-core systems.</dd></dl>
<p>This function queries the system to determine which CPU core the calling thread is currently scheduled on. Note that threads may migrate between cores, so this value may change over time unless thread affinity is set. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="pico_2multicore_2main_8c-example.html#a2">pico/multicore/main.c</a>, <a class="el" href="pico_2runloop_2main_8c-example.html#a1">pico/runloop/main.c</a>, and <a class="el" href="pico_2simplequeue_2main_8c-example.html#a2">pico/simplequeue/main.c</a>.</dd>
</dl>
</div>
</div>
<a id="ga677402551d5d11b4e3ee60391d5a4faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga677402551d5d11b4e3ee60391d5a4faf">&#9670;&nbsp;</a></span>sys_thread_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sys_thread_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SystemThread.html#ga44d92420e9c1148c746ce7e89a81075d">sys_thread_func_t</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a thread on any available core. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function to execute in the new thread </td></tr>
    <tr><td class="paramname">arg</td><td>Argument to pass to the thread function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if thread was created successfully, false if no cores available or error</dd></dl>
<p>Creates a new thread that executes the specified function with the given argument. The thread runs independently and terminates when the function returns. No cleanup or joining is required - the thread is fire-and-forget. On systems with multiple cores, the thread may be scheduled on any available core. </p>

</div>
</div>
<a id="ga1b72ef6424828a90881daa3559864cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b72ef6424828a90881daa3559864cf4">&#9670;&nbsp;</a></span>sys_thread_create_on_core()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sys_thread_create_on_core </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SystemThread.html#ga44d92420e9c1148c746ce7e89a81075d">sys_thread_func_t</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>core</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a thread on a specific core. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function to execute in the new thread </td></tr>
    <tr><td class="paramname">arg</td><td>Argument to pass to the thread function </td></tr>
    <tr><td class="paramname">core</td><td>Core number to run the thread on (0-based) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if thread was created on the specified core, false if core unavailable or error</dd></dl>
<p>Creates a new thread that executes the specified function on a specific CPU core. The thread runs independently and terminates when the function returns. If the specified core is not available or already in use, the function returns false. Core 0 is typically the main/boot core. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="pico_2multicore_2main_8c-example.html#a8">pico/multicore/main.c</a>, <a class="el" href="pico_2runloop_2main_8c-example.html#a19">pico/runloop/main.c</a>, and <a class="el" href="pico_2simplequeue_2main_8c-example.html#a11">pico/simplequeue/main.c</a>.</dd>
</dl>
</div>
</div>
<a id="gafd9cf2d40386c9cef130e39d39155293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd9cf2d40386c9cef130e39d39155293">&#9670;&nbsp;</a></span>sys_thread_numcores()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t sys_thread_numcores </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of CPU cores available on the host system. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of CPU cores available on the system. Returns 1 if the number of cores cannot be determined or if the system has only one core.</dd></dl>
<p>This function queries the system to determine the total number of processing cores available. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
  </ul>
</div>
</body>
</html>
